This is pdfTeX, Version 3.141592-1.40.3 (Web2C 7.5.6) (format=latex 2009.10.19)  21 JAN 2010 15:17
entering extended mode
**ross-rossnet-ug.tex
(./ross-rossnet-ug.tex
LaTeX2e <2005/12/01>
Babel <v3.8h> and hyphenation patterns for english, usenglishmax, dumylang, noh
yphenation, basque, bulgarian, coptic, welsh, czech, slovak, german, ngerman, d
anish, esperanto, spanish, catalan, galician, estonian, finnish, french, greek,
 monogreek, ancientgreek, croatian, hungarian, interlingua, ibycus, indonesian,
 icelandic, italian, latin, mongolian, dutch, norsk, polish, portuguese, romani
an, russian, slovenian, uppersorbian, serbian, swedish, turkish, ukenglish, ukr
ainian, loaded.
(/usr/share/texmf/tex/latex/base/article.cls
Document Class: article 2005/09/16 v1.4f Standard LaTeX document class
(/usr/share/texmf/tex/latex/base/size12.clo
File: size12.clo 2005/09/16 v1.4f Standard LaTeX file (size option)
)
\c@part=\count79
\c@section=\count80
\c@subsection=\count81
\c@subsubsection=\count82
\c@paragraph=\count83
\c@subparagraph=\count84
\c@figure=\count85
\c@table=\count86
\abovecaptionskip=\skip41
\belowcaptionskip=\skip42
\bibindent=\dimen102
)
(/usr/share/texmf/tex/latex/graphics/epsfig.sty
Package: epsfig 1999/02/16 v1.7a (e)psfig emulation (SPQR)

(/usr/share/texmf/tex/latex/graphics/graphicx.sty
Package: graphicx 1999/02/16 v1.0f Enhanced LaTeX Graphics (DPC,SPQR)

(/usr/share/texmf/tex/latex/graphics/keyval.sty
Package: keyval 1999/03/16 v1.13 key=value parser (DPC)
\KV@toks@=\toks14
)
(/usr/share/texmf/tex/latex/graphics/graphics.sty
Package: graphics 2006/02/20 v1.0o Standard LaTeX Graphics (DPC,SPQR)

(/usr/share/texmf/tex/latex/graphics/trig.sty
Package: trig 1999/03/16 v1.09 sin cos tan (DPC)
)
(/usr/lib/texmf/tex/latex/config/graphics.cfg
File: graphics.cfg 2007/01/18 v1.5 graphics configuration of teTeX/TeXLive
)
Package graphics Info: Driver file: dvips.def on input line 90.

(/usr/share/texmf/tex/latex/graphics/dvips.def
File: dvips.def 1999/02/16 v3.0i Driver-dependant file (DPC,SPQR)
))
\Gin@req@height=\dimen103
\Gin@req@width=\dimen104
)
\epsfxsize=\dimen105
\epsfysize=\dimen106
)
(/usr/share/texmf/tex/latex/ltxmisc/url.sty
\Urlmuskip=\muskip10
Package: url 2005/06/27  ver 3.2  Verb mode for urls, etc.
) (./ross-rossnet-ug.aux)
\openout1 = `ross-rossnet-ug.aux'.

LaTeX Font Info:    Checking defaults for OML/cmm/m/it on input line 29.
LaTeX Font Info:    ... okay on input line 29.
LaTeX Font Info:    Checking defaults for T1/cmr/m/n on input line 29.
LaTeX Font Info:    ... okay on input line 29.
LaTeX Font Info:    Checking defaults for OT1/cmr/m/n on input line 29.
LaTeX Font Info:    ... okay on input line 29.
LaTeX Font Info:    Checking defaults for OMS/cmsy/m/n on input line 29.
LaTeX Font Info:    ... okay on input line 29.
LaTeX Font Info:    Checking defaults for OMX/cmex/m/n on input line 29.
LaTeX Font Info:    ... okay on input line 29.
LaTeX Font Info:    Checking defaults for U/cmr/m/n on input line 29.
LaTeX Font Info:    ... okay on input line 29.
LaTeX Font Info:    External font `cmex10' loaded for size
(Font)              <14.4> on input line 50.
LaTeX Font Info:    External font `cmex10' loaded for size
(Font)              <7> on input line 50.
 [1

]
(./ross-rossnet-ug.toc
LaTeX Font Info:    External font `cmex10' loaded for size
(Font)              <12> on input line 2.
LaTeX Font Info:    External font `cmex10' loaded for size
(Font)              <8> on input line 2.
LaTeX Font Info:    External font `cmex10' loaded for size
(Font)              <6> on input line 2.
 [2])
\tf@toc=\write3
\openout3 = `ross-rossnet-ug.toc'.

 [3]
Overfull \hbox (12.81026pt too wide) in paragraph at lines 98--101
\OT1/cmtt/m/n/12 would like the rossnet source code installed along with the ro
ssnet-build directory. 
 []

[4]
Overfull \hbox (142.48532pt too wide) in paragraph at lines 138--138
[]\OT1/cmtt/m/n/12 mpirun -np 4 ./rn --scenario=tcp2 --synch=3 --clock-rate=266
7000000 --nkp=512 --batch=2 --gvt-interval=64[] 
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 142--153
\OT1/cmtt/m/n/12 ROSS allows for an application programmer to design an applica
tion with the ROSS API
 []


Overfull \hbox (68.38528pt too wide) in paragraph at lines 142--153
\OT1/cmtt/m/n/12 which will simulate some real world event. The model that we u
se for testing and educational
 []


Overfull \hbox (19.36008pt too wide) in paragraph at lines 142--153
\OT1/cmtt/m/n/12 purposes is called \OT1/cmtt/m/it/12 pcs\OT1/cmtt/m/n/12 , whi
ch is short for ``personal communications services''. PCS
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 142--153
\OT1/cmtt/m/n/12 simulates PCS/mobile phones calls being generated at a cell ph
one tower, and then moved
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 142--153
\OT1/cmtt/m/n/12 around to other towers at some later time, and then the phone 
call ends. At the end
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 142--153
\OT1/cmtt/m/n/12 of a phone call, another call or two may be generated. At the 
end of the simulation,
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 142--153
\OT1/cmtt/m/n/12 statistics regarding how often calls were blocked (busy) due t
o limited tower capacity
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 142--153
\OT1/cmtt/m/n/12 etc were collected. This details for this model can be found i
n [[]]. This paper is
 []


Overfull \hbox (18.08507pt too wide) in paragraph at lines 154--158
[]\OT1/cmtt/m/n/12 ROSS utilizes three main data structures in C. There is a PE
 (short for processor)
 []


Overfull \hbox (56.03528pt too wide) in paragraph at lines 154--158
\OT1/cmtt/m/n/12 struct, an LP struct (short for Logical Process) and an event 
struct. It will be necessary
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 154--158
\OT1/cmtt/m/n/12 to understand these structures if you are going to complete an
 application of your
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 160--170
\OT1/cmtt/m/n/12 This is the most basic part of the ROSS system. An event is si
mply that, an event
 []


Overfull \hbox (43.68527pt too wide) in paragraph at lines 160--170
\OT1/cmtt/m/n/12 that occurs in the system. The ROSS engine operates on events 
in what we call time-stamp
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 160--170
\OT1/cmtt/m/n/12 order. So, if we have three events with simulation timestamps 
of 5, 10 and 15, then
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 160--170
\OT1/cmtt/m/n/12 the application developer would expect for the ROSS engine to 
process the event with
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 160--170
\OT1/cmtt/m/n/12 a timestamp of 5 first, then 10 second and finally 15. Success
ful applications will
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 160--170
\OT1/cmtt/m/n/12 first prime the system with a few events, and then ensure that
 when events are processed
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 160--170
\OT1/cmtt/m/n/12 and leave the system that new events will be created. So, with
 this understanding
 []


Overfull \hbox (43.68527pt too wide) in paragraph at lines 160--170
\OT1/cmtt/m/n/12 of events, we need to know what data fields within the struct 
are available and important
 []

[5]
Overfull \hbox (5.73506pt too wide) in paragraph at lines 208--210
[]\OT1/cmtt/m/n/12 This is the simulation time stamp for this event. This would
 be 5, 10, or 15 in
 []


Overfull \hbox (11.91006pt too wide) in paragraph at lines 219--222
[]\OT1/cmtt/m/n/12 This bit-field is used by the ROSS engine to determine in wh
ich data structure(s)
 []

[6]
Overfull \hbox (28.70607pt too wide) in paragraph at lines 243--249
[]\OT1/cmtt/m/n/12 The dest[]lp pointer is the destination LP (logical process)
 for this event. We also
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 243--249
\OT1/cmtt/m/n/12 keep track of the source LP, some state-saving information and
 a bit-field per event.
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 243--249
\OT1/cmtt/m/n/12 The bit-field is available in the ROSS API for application use
 and ROSS does not try
 []


Overfull \hbox (48.13127pt too wide) in paragraph at lines 243--249
\OT1/cmtt/m/n/12 to impose any limits on the logical functionality of this data
 type. The lp[]state pointer
 []


Overfull \hbox (28.70607pt too wide) in paragraph at lines 264--267
[]\OT1/cmtt/m/n/12 The tw[]message pointer is critical to an event because this
 is where the application
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 264--267
\OT1/cmtt/m/n/12 data is kept. ROSS provides in the API for the proper allocati
on of this pointer. 
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 278--285
\OT1/cmtt/m/n/12 The LP (logical Process) struct is essential to the applicatio
n programmer because
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 278--285
\OT1/cmtt/m/n/12 it provides some logical environment for events to exist in. I
n PCS, events are cell
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 278--285
\OT1/cmtt/m/n/12 phones, and LPs are cell phone towers. Cell phones initiate ca
lls which require lines
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 278--285
\OT1/cmtt/m/n/12 on a towers. Calls move from tower to tower. When a call ends,
 a line in a tower
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 278--285
\OT1/cmtt/m/n/12 is freed. If we were to model the Internet using ROSS, events 
might be TCP/IP packets,
 []

[7]
Overfull \hbox (36.61008pt too wide) in paragraph at lines 304--314
[]\OT1/cmtt/m/n/12 LPs can be many different types within ROSS. The application
 must specify these types
 []


Overfull \hbox (0.96pt too wide) in paragraph at lines 304--314
\OT1/cmtt/m/n/12 and that information is recorded in the \OT1/cmtt/m/it/12 type
 \OT1/cmtt/m/n/12 variable you see here. LPs also have
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 304--314
\OT1/cmtt/m/n/12 unique ids, and are assigned to PEs (processors). The applicat
ion developer must create
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 304--314
\OT1/cmtt/m/n/12 each lp and assign it to a PE. ROSS does no dynamic load balan
cing, so it is left to
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 304--314
\OT1/cmtt/m/n/12 the programmer to determine where sinks and sources should be 
placed. These simulations
 []


Overfull \hbox (43.68527pt too wide) in paragraph at lines 304--314
\OT1/cmtt/m/n/12 typically work best with abstracted LPs which are essentially 
all the same. For example,
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 304--314
\OT1/cmtt/m/n/12 a cell phone tower has channels available for placing calls. T
he cell tower lp is
 []


Overfull \hbox (43.68527pt too wide) in paragraph at lines 304--314
\OT1/cmtt/m/n/12 responsible for allocating and freeing its own channels. The R
OSS API provides functions
 []


Overfull \hbox (4.00606pt too wide) in paragraph at lines 328--332
[]\OT1/cmtt/m/n/12 The cur[]state pointer is used to determine the current appl
ication data for this
 []


Overfull \hbox (11.08125pt too wide) in paragraph at lines 328--332
\OT1/cmtt/m/n/12 lp. The cur[]event pointer is the event currently being proces
sed by this lp. These
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 328--332
\OT1/cmtt/m/n/12 are used by the ROSS engine to determine which is the next eve
nt to process on an lp
 []

[8]
Overfull \hbox (5.73506pt too wide) in paragraph at lines 347--351
[]\OT1/cmtt/m/n/12 The kp pointer is the owning kernel process for this LP. The
 Kernel Process data
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 347--351
\OT1/cmtt/m/n/12 structure will be discussed next. However, from the model deve
lopers point of view,
 []


Overfull \hbox (42.78508pt too wide) in paragraph at lines 356--359
[]\OT1/cmtt/m/n/12 This time element is the time of the last processed event in
 this lp. The ROSS engine
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 356--359
\OT1/cmtt/m/n/12 uses this information to determine it's current time in the si
mulation and is not part
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 370--372
\OT1/cmtt/m/n/12 A Kernel Process (KP) holds our state for the Kernel Process (
KP), which consists only
 []

[9]
Overfull \hbox (5.73506pt too wide) in paragraph at lines 392--402
[]\OT1/cmtt/m/n/12 This next series of variables is used to contain the process
ed event list. This
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 392--402
\OT1/cmtt/m/n/12 is the list of events that is keep around for purposes of bein
g able to rollback LPs.
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 392--402
\OT1/cmtt/m/n/12 Please note, that because we are aggregating the processed eve
nt-list of many LPs,
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 392--402
\OT1/cmtt/m/n/12 a single rollback at the KP level could result in many LPs bei
ng rolled back, so of
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 392--402
\OT1/cmtt/m/n/12 which are not necessary. This is a trade-off in design between
 the need for efficient
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 392--402
\OT1/cmtt/m/n/12 fossil collection and ``false'' rollbacks. Currently, ``false'
' rollbacks do not appear
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 392--402
\OT1/cmtt/m/n/12 to be an issue in the models we have tested to date. For more 
information on KPs see
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 427--432
\OT1/cmtt/m/n/12 Most of what is contained within the PE (processor) struct is 
internal to the ROSS
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 427--432
\OT1/cmtt/m/n/12 engine so it is not shown here. There is one field of note and
 that is the id field.
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 427--432
\OT1/cmtt/m/n/12 Within a machine, each processor is assigned a unique PE id, s
tarting from zero and
 []


Overfull \hbox (68.38528pt too wide) in paragraph at lines 434--444
\OT1/cmtt/m/n/12 The ROSS API is pretty small and gives the application designe
r a fair amount of flexibility.
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 434--444
\OT1/cmtt/m/n/12 In this section we will discuss each of the functions availabl
e to the application
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 434--444
\OT1/cmtt/m/n/12 programmer. We will note which functions are required where ne
cessary. The first
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 434--444
\OT1/cmtt/m/n/12 job of any application is to provide a main function for ROSS 
to be compiled against.
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 434--444
\OT1/cmtt/m/n/12 In this main function we will need to call a couple required f
unctions in order to
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 434--444
\OT1/cmtt/m/n/12 setup the system properly. In this section we will use the PCS
 application to highlight
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 434--444
\OT1/cmtt/m/n/12 how these functions are realized. We will start by going throu
gh the main function,
 []

[10]
Overfull \hbox (18.08507pt too wide) in paragraph at lines 449--451
[]\OT1/cmtt/m/n/12 In the ross subdirectory, you will see a Makefile with the f
ollowing parameters at
 []


Overfull \hbox (5.73506pt too wide) in paragraph at lines 481--484
[]\OT1/cmtt/m/n/12 You only need to set the right architecture and make sure th
e mpicc pre-compiler
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 481--484
\OT1/cmtt/m/n/12 for MPI is in the path. The other options are advanced setting
s and should only be
 []


Overfull \hbox (24.26007pt too wide) in paragraph at lines 485--487
[]\OT1/cmtt/m/n/12 If you wish to increase/change the level of optmization, cha
nge the CFLAGS variable
 []

[11]
Overfull \hbox (5.73506pt too wide) in paragraph at lines 518--521
[]\OT1/cmtt/m/n/12 Next to build a sample model, such as pcs, change directory 
to models/pcs. Edit
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 518--521
\OT1/cmtt/m/n/12 the CFLAGS to change the compiler optimization level and type 
make. Then to execute
 []


Overfull \hbox (11.91006pt too wide) in paragraph at lines 526--531
[]\OT1/cmtt/m/n/12 Here, the pcs model will run for the default 1,000,000 time 
units on 8 processors
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 526--531
\OT1/cmtt/m/n/12 which have a 2.667 GHz clock rate for cycle timer info. The ba
tch and gvt-interval
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 526--531
\OT1/cmtt/m/n/12 parameters determine how frequently GVT is set. See our paper 
[[]] and others on the
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 533--541
\OT1/cmtt/m/n/12 The purpose of the main function initialize the simulation mod
el which includes the
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 533--541
\OT1/cmtt/m/n/12 LP to PE mapping. By default it is a linear mapping. This main
 function builds a
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 533--541
\OT1/cmtt/m/n/12 square mapping of LPs to PEs. It could be considered a matrix,
 but why make things
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 533--541
\OT1/cmtt/m/n/12 more complicated. Think of a map where cell phone towers are p
laced into a grid. Each
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 533--541
\OT1/cmtt/m/n/12 grid space is really a processor with an lp inside of it. We m
ay have many more cell
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 533--541
\OT1/cmtt/m/n/12 phone towers than grid spaces, so some grid spaces will have m
any towers. We would
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 533--541
\OT1/cmtt/m/n/12 like to achieve a mapping such that all grid spaces have an eq
ual number of towers. 
 []

[12]
Overfull \hbox (55.13509pt too wide) in paragraph at lines 548--555
[]\OT1/cmtt/m/n/12 These are the local variables we will be using to determine 
the proper mapping. Because
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 548--555
\OT1/cmtt/m/n/12 this is a grid, we will need an x and y coordinate. Also, we w
ill have virtual x and
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 548--555
\OT1/cmtt/m/n/12 y coordinates, xvp and yvp (for x-virtual processor and y-virt
ual processor). We have
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 548--555
\OT1/cmtt/m/n/12 a simple counter, i, the number of LPs to map, TWnlp (Time War
p number of LPs), the
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 548--555
\OT1/cmtt/m/n/12 number of processors in this machine to use, TWnpe (Time Warp 
number of PEs) and an
 []


Overfull \hbox (18.08507pt too wide) in paragraph at lines 567--569
[]\OT1/cmtt/m/n/12 We have some #define variables at the top of this file to ma
ke changing the number
 []


Overfull \hbox (18.08507pt too wide) in paragraph at lines 575--580
[]\OT1/cmtt/m/n/12 We must have a nice machine because there appears to be four
 processors in it. It
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 575--580
\OT1/cmtt/m/n/12 may really only have two processors, in which case our simulat
ion would be hampered
 []


Overfull \hbox (49.86028pt too wide) in paragraph at lines 575--580
\OT1/cmtt/m/n/12 by context switching. The TWnpe variable should really be set 
to the number of processors
 []


Overfull \hbox (6.72305pt too wide) in paragraph at lines 585--590
[]\OT1/cmtt/m/n/12 Here we come across our first global variable, g[]tw[]ts[]en
d (Global Time Warp Time
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 585--590
\OT1/cmtt/m/n/12 Stamp Endtime). This must be a fast machine because we are tel
ling the simulation
 []


Overfull \hbox (68.38528pt too wide) in paragraph at lines 585--590
\OT1/cmtt/m/n/12 here to run to 100 million time stamps. This is a required ste
p if you like your simulations
 []


Overfull \hbox (11.91006pt too wide) in paragraph at lines 603--608
[]\OT1/cmtt/m/n/12 This variable is the number of virtual processes per process
or. The math here is
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 603--608
\OT1/cmtt/m/n/12 not really important to us unless we are interested in doing t
hese types of mappings.
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 603--608
\OT1/cmtt/m/n/12 You'll notice however, that we are simply taking the number of
 grid spaces we desire
 []

[13]
Overfull \hbox (5.73506pt too wide) in paragraph at lines 613--614
[]\OT1/cmtt/m/n/12 We love printf's. We love them more when they are followed b
y a fflush(stdout); 
 []


Overfull \hbox (55.13509pt too wide) in paragraph at lines 620--623
[]\OT1/cmtt/m/n/12 This is the first function we are required to call in ROSS. 
The purpose of this function
 []


Overfull \hbox (28.70607pt too wide) in paragraph at lines 631--634
[]\OT1/cmtt/m/n/12 We pass the argc and argv parameters from main into tw[]init
 for parsing which setups
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 631--634
\OT1/cmtt/m/n/12 on the internals of the simulation model you desire. When then
 declare for each LP,
 []


Overfull \hbox (16.35606pt too wide) in paragraph at lines 656--662
[]\OT1/cmtt/m/n/12 After tw[]init has parsed the commandline args, we setup our
 model specific mapping
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 656--662
\OT1/cmtt/m/n/12 table. In this case, it is a simple NxN grid on which the LPs 
are placed. Internally
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 656--662
\OT1/cmtt/m/n/12 within ROSS, the default mapping across processors is ``linear
''. That is, we given
 []


Overfull \hbox (9.41826pt too wide) in paragraph at lines 656--662
\OML/cmm/m/it/12 p$ \OT1/cmtt/m/n/12 processors, we map an $\OML/cmm/m/it/12 L=
p$ \OT1/cmtt/m/n/12 slice of LPs to each processor in linear order, where $\OML
/cmm/m/it/12 L$
 []


Overfull \hbox (42.78508pt too wide) in paragraph at lines 663--668
[]\OT1/cmtt/m/n/12 Now that we have the appropriate pointers to LPs and KPs, we
 can set it's type. Since
 []


Overfull \hbox (29.60626pt too wide) in paragraph at lines 663--668
\OT1/cmtt/m/n/12 all PCS LP types are cell phone towers, all LP types will be T
W[]CELL, another #define..
 []


Overfull \hbox (4.90625pt too wide) in paragraph at lines 663--668
\OT1/cmtt/m/n/12 in this case, TW[]CELL is defined to be 1, or, the first eleme
nt in the mylps array.
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 663--668
\OT1/cmtt/m/n/12 PLEASE NOTE, YOUR LP TYPE NUMBERS CANNOT START WITH ZERO. THE 
ZERO TYPE IS USED TO
 []

[14]
Overfull \hbox (10.18106pt too wide) in paragraph at lines 669--673
[]\OT1/cmtt/m/n/12 Other than calling tw[]run(), as you see below, that's reall
y about it to the main
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 669--673
\OT1/cmtt/m/n/12 function. Some initializing of the simulator, and some assignm
ent of LPs to PEs and
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 669--673
\OT1/cmtt/m/n/12 we're ready to go. Before we start running, we will be sure to
 zero out our application
 []


Overfull \hbox (5.73506pt too wide) in paragraph at lines 690--694
[]\OT1/cmtt/m/n/12 If we were lucky and our simulation completed without error,
 we can then compute
 []


Overfull \hbox (68.38528pt too wide) in paragraph at lines 690--694
\OT1/cmtt/m/n/12 and print our statistics. ROSS knows nothing about our applica
tion, so these are application
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 708--711
\OT1/cmtt/m/n/12 Next we'd like to view some of this application and try to cla
rify how we make something
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 708--711
\OT1/cmtt/m/n/12 meaningful out of this simulator. We talked about LPs having t
ypes. In PCS we had
 []

[15]
Overfull \hbox (28.70607pt too wide) in paragraph at lines 712--723
[]\OT1/cmtt/m/n/12 TW[]CELL is simply a #define which allows us to access the f
irst element in the array
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 712--723
\OT1/cmtt/m/n/12 mylps. In mylps, we have declared our event handlers. There ar
e five major events
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 712--723
\OT1/cmtt/m/n/12 handlers in ROSS, initialization, processing, rollback, and a 
final state. Remember
 []


Overfull \hbox (43.68527pt too wide) in paragraph at lines 712--723
\OT1/cmtt/m/n/12 that ROSS executes speculatively across processors, and that f
rom time to time processors
 []


Overfull \hbox (49.86028pt too wide) in paragraph at lines 712--723
\OT1/cmtt/m/n/12 may process events out of order, in which case the system will
 need to be able to rollback
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 712--723
\OT1/cmtt/m/n/12 the offending events, process the out of order event, and then
 begin executing again.
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 712--723
\OT1/cmtt/m/n/12 This is why we require a rollback event handler in ROSS. We al
so have a state-saving
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 712--723
\OT1/cmtt/m/n/12 handler which is not used in ROSS because state-saving is not 
as efficient a technique
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 782--782
[]         \OT1/cmtt/m/n/12 * event on the LP and cleaning up the LP for stats 
computation/collecting[] 
 []

[16]
Overfull \hbox (16.35606pt too wide) in paragraph at lines 784--786
[]\OT1/cmtt/m/n/12 Alternatively, you could declare and initialize your tw[]lpt
ype array as follows as
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 800--804
\OT1/cmtt/m/n/12 Before we look at one of these handlers, lets first see what t
he application variables
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 800--804
\OT1/cmtt/m/n/12 are so that we will be familiar with them when looking through
 the code. Below we
 []


Overfull \hbox (42.78508pt too wide) in paragraph at lines 805--807
[]\OT1/cmtt/m/n/12 All ROSS applications must include ross.h if they would like
 to have their application
 []


Overfull \hbox (24.26007pt too wide) in paragraph at lines 812--816
[]\OT1/cmtt/m/n/12 These #defines are application specific and determine the nu
mber of LPs in both the
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 812--816
\OT1/cmtt/m/n/12 x and y direction. They are used, as we saw, in the mapping of
 LPs and KPs to PEs.
 []

[17]
Overfull \hbox (5.73506pt too wide) in paragraph at lines 827--830
[]\OT1/cmtt/m/n/12 Channels are phone lines in a cell tower. Here we see that e
ach cell tower will
 []


Overfull \hbox (18.08507pt too wide) in paragraph at lines 836--842
[]\OT1/cmtt/m/n/12 We must define how large a time step to make in the simulati
on for certain events.
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 836--842
\OT1/cmtt/m/n/12 Here, we define a cell phone moving from one tower to another 
to take 4500 time stamp
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 836--842
\OT1/cmtt/m/n/12 units. The next call average to be 360 time stamp units, and t
he average call length
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 836--842
\OT1/cmtt/m/n/12 to be 180 time step units, which in this case is equated to se
conds in the real system
 []


Overfull \hbox (24.26007pt too wide) in paragraph at lines 849--853
[]\OT1/cmtt/m/n/12 This is the number of initial calls to start with per cell p
hone tower. Since this
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 849--853
\OT1/cmtt/m/n/12 application came from Georgia Tech, and we wanted to preserve 
it in ROSS, we did not
 []


Overfull \hbox (55.13509pt too wide) in paragraph at lines 858--861
[]\OT1/cmtt/m/n/12 Here we have more application logic. These values were picke
d to have logical meanings,
 []

[18]
Overfull \hbox (24.26007pt too wide) in paragraph at lines 891--898
[]\OT1/cmtt/m/n/12 This is the state of a cell tower (lp). We said earlier that
 our application would
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 891--898
\OT1/cmtt/m/n/12 have to be responsible for maintaining it's own logic and we d
o that with this struct.
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 891--898
\OT1/cmtt/m/n/12 This is not to be confused with state-saving. We can see here 
the developer is tracking
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 891--898
\OT1/cmtt/m/n/12 the number of portables that have come through a tower, the nu
mber of attempts which
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 891--898
\OT1/cmtt/m/n/12 are made to the tower, the number of blocks (busy signals) giv
en, and of course the
 []


Overfull \hbox (11.91006pt too wide) in paragraph at lines 926--931
[]\OT1/cmtt/m/n/12 Here is something we recognize from the initialization steps
. We allocated space
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 926--931
\OT1/cmtt/m/n/12 in every event we allocate for this struct, but what does it d
o' Here, it keeps track
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 926--931
\OT1/cmtt/m/n/12 of the method name to run, the time stamp at which the call mo
ved, ended, started a
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 926--931
\OT1/cmtt/m/n/12 new call. We also log the channel type, or phone line type and
 the RC struct value. 
 []

[19]
Overfull \hbox (36.61008pt too wide) in paragraph at lines 944--947
[]\OT1/cmtt/m/n/12 Here we find a struct filled with variables for keeping trac
king of statistics. When
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 944--947
\OT1/cmtt/m/n/12 the simulation ends, we can call the statistics compute functi
on and fill in these
 []


Overfull \hbox (18.08507pt too wide) in paragraph at lines 962--965
[]\OT1/cmtt/m/n/12 Function declarations are included to show how each function
 might be defined. In
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 962--965
\OT1/cmtt/m/n/12 this document we are not going to cover each function, but onl
y those which illustrate
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 983--983
[]\OT1/cmtt/m/n/12 void Cell_EventHandler(struct State *SV, tw_bf * CV, struct 
Msg_Data *M, tw_lp * lp);[] 
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 983--983
[]\OT1/cmtt/m/n/12 void Cell_CompletionCall(struct State *SV, tw_bf * CV, struc
t Msg_Data *M, tw_lp * lp);[] 
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 983--983
[]\OT1/cmtt/m/n/12 void Cell_MoveCallIn(struct State *SV, tw_bf * CV, struct Ms
g_Data *M, tw_lp * lp);[] 
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 983--983
[]\OT1/cmtt/m/n/12 void Cell_MoveCallOut(struct State *SV, tw_bf * CV, struct M
sg_Data *M, tw_lp * lp);[] 
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 983--983
[]\OT1/cmtt/m/n/12 void RC_Cell_EventHandler(struct State *SV, tw_bf * CV, stru
ct Msg_Data *M, tw_lp * lp);[] 
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 983--983
[]\OT1/cmtt/m/n/12 void RC_Cell_NextCall(struct State *SV, tw_bf * CV, struct M
sg_Data *M, tw_lp * lp);[] 
 []


Overfull \hbox (49.86028pt too wide) in paragraph at lines 983--983
[]\OT1/cmtt/m/n/12 void RC_Cell_CompletionCall(struct State *SV, tw_bf * CV, st
ruct Msg_Data *M, tw_lp * lp);[] 
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 983--983
[]\OT1/cmtt/m/n/12 void RC_Cell_MoveCallIn(struct State *SV, tw_bf * CV, struct
 Msg_Data *M, tw_lp * lp);[] 
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 983--983
[]\OT1/cmtt/m/n/12 void RC_Cell_MoveCallOut(struct State *SV, tw_bf * CV, struc
t Msg_Data *M, tw_lp * lp);[] 
 []


Overfull \hbox (11.91006pt too wide) in paragraph at lines 985--987
[]\OT1/cmtt/m/n/12 This final variable is a global struct by which we will coll
ect statistics at the
 []

[20]
Overfull \hbox (72.83128pt too wide) in paragraph at lines 993--997
\OT1/cmtt/m/n/12 Going back to the mylp array, recall that the initialization f
unction was called Cell[]StartUp.
 []


Overfull \hbox (41.95627pt too wide) in paragraph at lines 993--997
\OT1/cmtt/m/n/12 When we call tw[]run(), ROSS will go through each LP invoking 
it's assigned initialization
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 993--997
\OT1/cmtt/m/n/12 function. We are passed through a state vector and a pointer t
o the corresponding
 []


Overfull \hbox (42.78508pt too wide) in paragraph at lines 1030--1034
[]\OT1/cmtt/m/n/12 This is where we prime the system with events or phone calls
. GenInitPortables simply
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 1030--1034
\OT1/cmtt/m/n/12 returns that BigN variable we've already seen, so we know that
 each LP will start out
 []

[21]
Overfull \hbox (5.73506pt too wide) in paragraph at lines 1042--1047
[]\OT1/cmtt/m/n/12 ROSS includes a reversible random number generator, and here
 we see the ROSS API
 []


Overfull \hbox (62.21028pt too wide) in paragraph at lines 1042--1047
\OT1/cmtt/m/n/12 call to generate an exponential value. By default, each LP has
 1 RNG stream. By increasing
 []


Overfull \hbox (13.79825pt too wide) in paragraph at lines 1042--1047
\OT1/cmtt/m/n/12 g[]nRNG[]per[]LP, you can change the number from a default num
ber of RNG streams per LP.
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 1042--1047
\OT1/cmtt/m/n/12 A complete listing of all random number distributions and thei
r respective interfaces
 []


Overfull \hbox (11.91006pt too wide) in paragraph at lines 1053--1056
[]\OT1/cmtt/m/n/12 We need to determine the status of this call. It may already
 be completed, which
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1053--1056
\OT1/cmtt/m/n/12 would be in error because we are just beginning the simulation
. It may generate a
 []


Overfull \hbox (5.73506pt too wide) in paragraph at lines 1065--1070
[]\OT1/cmtt/m/n/12 If we are generating a new call, which we need to do in orde
r for the simulation
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1065--1070
\OT1/cmtt/m/n/12 to continue advancing, we want to create a new event and place
 it into the system.
 []


Overfull \hbox (42.94426pt too wide) in paragraph at lines 1065--1070
\OT1/cmtt/m/n/12 So we have four new, and most widely used ROSS API functions, 
tw[]event[]new, tw[]event[]send,
 []


Overfull \hbox (10.18106pt too wide) in paragraph at lines 1071--1074
[]\OT1/cmtt/m/n/12 The function tw[]now will return to us the current time (in 
the simulation) for an
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 1071--1074
\OT1/cmtt/m/n/12 LP. Remember that this may be out of sync with other LPs becau
se we are speculatively
 []


Overfull \hbox (27.96506pt too wide) in paragraph at lines 1075--1080
[]\OT1/cmtt/m/n/12 We create a new event by calling tw[]event[]new(tw[]lpid des
tination, tw[]stime ts, tw[]lp
 []


Overfull \hbox (62.21028pt too wide) in paragraph at lines 1075--1080
\OT1/cmtt/m/n/12 * sender) where sender is the current LP and destination is th
e global ID of the destination
 []


Overfull \hbox (19.7349pt too wide) in paragraph at lines 1075--1080
\OT1/cmtt/m/n/12 LP. ts is the time stamp at which this event was sent into the
 \OT1/cmtt/m/it/12 future \OT1/cmtt/m/n/12 and is the time
 []


Overfull \hbox (30.43507pt too wide) in paragraph at lines 1081--1085
[]\OT1/cmtt/m/n/12 We now need this new events message data pointer so that we 
can fill it in. We call
 []


Overfull \hbox (38.49826pt too wide) in paragraph at lines 1081--1085
\OT1/cmtt/m/n/12 tw[]event[]data, passing to it the event we want the Msg[]Data
 pointer for, and are returned
 []


Overfull \hbox (20.80206pt too wide) in paragraph at lines 1086--1089
[]\OT1/cmtt/m/n/12 We then schedule the event into the future by calling tw[]ev
ent[]send. In this case,
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 1086--1089
\OT1/cmtt/m/n/12 we are always sending the event to ourselves because the sourc
e and destination LPs
 []

[22]
Overfull \hbox (18.08507pt too wide) in paragraph at lines 1103--1116
[]\OT1/cmtt/m/n/12 Here we would like to move a call to another tower, or LP. F
irst we want to figure
 []


Overfull \hbox (34.05226pt too wide) in paragraph at lines 1103--1116
\OT1/cmtt/m/n/12 out where to send this event to, so we call tw[]rand[]integer 
(remember all LP identifiers
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1103--1116
\OT1/cmtt/m/n/12 are integers) and set that as our destination index. We then u
se our neighbor array
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1103--1116
\OT1/cmtt/m/n/12 to find a neighbor to this LP. Once we have done all this, we 
will have an global LP
 []


Overfull \hbox (49.86028pt too wide) in paragraph at lines 1103--1116
\OT1/cmtt/m/n/12 id for newcell. We will again create a new event with this inf
ormation as the destination
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1103--1116
\OT1/cmtt/m/n/12 LP, the time the event was received into the system, and of co
urse our source LP. It
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1103--1116
\OT1/cmtt/m/n/12 is important to note here that when determining the time stamp
 offset at which the
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 1103--1116
\OT1/cmtt/m/n/12 new event will enter the system must be at least zero. We woul
d not want this called
 []


Overfull \hbox (43.68527pt too wide) in paragraph at lines 1103--1116
\OT1/cmtt/m/n/12 to be moved backwards in time. Again we fill in the message da
ta fields with application
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 1103--1116
\OT1/cmtt/m/n/12 data and send the event to the destination LP. Because we mapp
ed LPs to PEs, ROSS will
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1103--1116
\OT1/cmtt/m/n/12 handle the mechanism of actually moving events around in the s
ystem and processing
 []

[23]
Overfull \hbox (18.08507pt too wide) in paragraph at lines 1144--1156
[]\OT1/cmtt/m/n/12 And that's all there is to initializing the system! At this 
point ROSS has 4 PEs,
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1144--1156
\OT1/cmtt/m/n/12 each with a single lp. Each lp has been primed with 16 events 
or more. Now it is
 []


Overfull \hbox (43.68527pt too wide) in paragraph at lines 1144--1156
\OT1/cmtt/m/n/12 a simple matter for ROSS to being emptying lp queues and proce
ssing events. An important
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 1144--1156
\OT1/cmtt/m/n/12 attribute not to be overlooked here is that if your events to 
not generate at least
 []


Overfull \hbox (74.56029pt too wide) in paragraph at lines 1144--1156
\OT1/cmtt/m/n/12 one other event before leaving the system, the simulation may 
be starved and run indefinitely,
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1144--1156
\OT1/cmtt/m/n/12 having not enough events to reach the end time that you specif
ied in main. So it is
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1144--1156
\OT1/cmtt/m/n/12 important to continually generate events. Equally important is
 to realize that if
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1144--1156
\OT1/cmtt/m/n/12 each event generates too many events before leaving the system
, then ROSS may not be
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 1144--1156
\OT1/cmtt/m/n/12 able to allocate enough buffers and never progress, and the sy
stem will be considered
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1144--1156
\OT1/cmtt/m/n/12 'choked'. So it is important for the application programmer to
 realize a 1:1 or 1:2
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 1159--1163
\OT1/cmtt/m/n/12 The next function which is important to look at is the event h
andler routine. ROSS
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1159--1163
\OT1/cmtt/m/n/12 will dequeue an event from an lp struct and try to process it,
 or call your handler.
 []


Overfull \hbox (5.73506pt too wide) in paragraph at lines 1164--1177
[]\OT1/cmtt/m/n/12 Here we see a more complex function. Its parameters include 
the state vector, a
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 1164--1177
\OT1/cmtt/m/n/12 bit field (which is provided to your application), the message
 data and of course the
 []


Overfull \hbox (43.68527pt too wide) in paragraph at lines 1164--1177
\OT1/cmtt/m/n/12 current lp this event is scheduled onto. We simply look at the
 message data to determine
 []


Overfull \hbox (17.25626pt too wide) in paragraph at lines 1164--1177
\OT1/cmtt/m/n/12 which function we would like to call. In Cell[]StartUp we set 
the MethodName field in
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1164--1177
\OT1/cmtt/m/n/12 all of our events, and here we exercise that information. Rela
tively simple. You
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1164--1177
\OT1/cmtt/m/n/12 will also note that there are a few other things going on here
. First, we set the
 []


Overfull \hbox (29.60626pt too wide) in paragraph at lines 1164--1177
\OT1/cmtt/m/n/12 reverse-computation, while-one loop to zero. Also, we have two
 new API calls, tw[]error
 []


Overfull \hbox (52.57727pt too wide) in paragraph at lines 1164--1177
\OT1/cmtt/m/n/12 and tw[]exit. ROSS tries to provide some convenient way of han
dling errors. Every tw[]error
 []


Overfull \hbox (17.25626pt too wide) in paragraph at lines 1164--1177
\OT1/cmtt/m/n/12 call's first parameter is TW[]LOC, which is the file location 
of this call. Second is
 []


Overfull \hbox (11.08125pt too wide) in paragraph at lines 1164--1177
\OT1/cmtt/m/n/12 the string parameter, and third are the fields for the string.
 The tw[]exit function
 []

[24]
Overfull \hbox (18.08507pt too wide) in paragraph at lines 1207--1210
[]\OT1/cmtt/m/n/12 You probably thought that completing a telephone call was a 
simple matter, but for
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1207--1210
\OT1/cmtt/m/n/12 simulation designers it is where the work really begins. It is
 the point at which
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 1254--1254
[]               \OT1/cmtt/m/n/12 tw_error(TW_LOC, "APP_ERROR(2): CompletionCal
l: Bad ChannelType(%d) \n",[] 
 []

[25]
Overfull \hbox (31.33527pt too wide) in paragraph at lines 1286--1286
[]               \OT1/cmtt/m/n/12 tw_error(TW_LOC, "APP_ERROR(NextCall): Comple
tionCallTS(%lf) Is Min \n",[] 
 []

[26]
Overfull \hbox (12.81026pt too wide) in paragraph at lines 1316--1338
\OT1/cmtt/m/n/12 So what's left? Well, because ROSS is a speculative execution 
simulator, this means
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1316--1338
\OT1/cmtt/m/n/12 that we may get into trouble from time to time when LPs get ah
ead or fall behind one
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1316--1338
\OT1/cmtt/m/n/12 another. LPs may not always be of the same time. Some may be s
inks and some may be
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 1316--1338
\OT1/cmtt/m/n/12 sources. Some may never have events scheduled to them at all. 
ROSS guarantees the
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1316--1338
\OT1/cmtt/m/n/12 application designer that the system will run through all thes
e inconsistencies, and
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1316--1338
\OT1/cmtt/m/n/12 without thrashing, but how does it take advantage of the rollb
ack technology? Put
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 1316--1338
\OT1/cmtt/m/n/12 simply, when ROSS realizes an out-of-order event, it runs back
 every event for that
 []


Overfull \hbox (49.86028pt too wide) in paragraph at lines 1316--1338
\OT1/cmtt/m/n/12 lp until it reaches the correct point in time when that event 
was to be executed. Because
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 1316--1338
\OT1/cmtt/m/n/12 this out-of-order event is going to possibly change events in 
the future, those future
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1316--1338
\OT1/cmtt/m/n/12 events that we rolled back must be restored and rescheduled. R
escheduled is simple,
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1316--1338
\OT1/cmtt/m/n/12 but how can you restore an event without saving it?s original 
state? Simply run the
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1316--1338
\OT1/cmtt/m/n/12 formulas backwards. This is called reverse computation and is 
as difficult a task
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 1316--1338
\OT1/cmtt/m/n/12 as it sounds, but ROSS simplifies it for the application progr
ammer. The application
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1316--1338
\OT1/cmtt/m/n/12 programmer is required to provide ROSS with a proper rollback 
event handler. When
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 1316--1338
\OT1/cmtt/m/n/12 ROSS rolls back an event, this handler is invoked and (hopeful
ly) the event is restored
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1316--1338
\OT1/cmtt/m/n/12 to its original state. In order to accomplish this, ROSS provi
des a random number
 []


Overfull \hbox (49.86028pt too wide) in paragraph at lines 1316--1338
\OT1/cmtt/m/n/12 generator that is capable of being run backwards. This makes l
ife easy for the developer,
 []


Overfull \hbox (11.91006pt too wide) in paragraph at lines 1339--1342
[]\OT1/cmtt/m/n/12 All we are doing here is determining which function was used
 when processing this
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1363--1363
[]\OT1/cmtt/m/n/12 RC_Cell_EventHandler(struct State *SV, tw_bf * CV, struct Ms
g_Data *M, tw_lp * lp)[] 
 []

[27]
Overfull \hbox (18.08507pt too wide) in paragraph at lines 1365--1367
[]\OT1/cmtt/m/n/12 Let's look at one of those functions, specifically, the reve
rse computation of the
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 1378--1378
[] \OT1/cmtt/m/n/12 RC_Cell_CompletionCall(struct State *SV, tw_bf * CV, struct
 Msg_Data *M, tw_lp * lp)[] 
 []


Overfull \hbox (48.96008pt too wide) in paragraph at lines 1380--1388
[]\OT1/cmtt/m/n/12 Notice here that we finally use the reverse-computation, whi
le one counter to determine
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 1380--1388
\OT1/cmtt/m/n/12 how many times the random number generator was invoked. Every 
move call caused the
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1380--1388
\OT1/cmtt/m/n/12 RNG to be invoked twice, and so for each move call the RNG mus
t be reversed twice.
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1380--1388
\OT1/cmtt/m/n/12 It would have been nice if this variable had been named someth
ing more meaningful,
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 1380--1388
\OT1/cmtt/m/n/12 but again, we tried to maintain code integrity in order to pro
ve results against GTW.
 []


Overfull \hbox (55.13509pt too wide) in paragraph at lines 1398--1407
[]\OT1/cmtt/m/n/12 This is all there is to it. We simply need to reverse comput
e the application variables
 []


Overfull \hbox (17.25626pt too wide) in paragraph at lines 1398--1407
\OT1/cmtt/m/n/12 we set in Cell[]CompletionCall. Which means decrement that whi
ch was incremented. We
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1398--1407
\OT1/cmtt/m/n/12 use the lp id to rewind the random number generator so that in
 the future, when this
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1398--1407
\OT1/cmtt/m/n/12 event is re-executed, it will come up with the same value as t
he first time it was
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1398--1407
\OT1/cmtt/m/n/12 executed. Why do we care about this random number generator? I
t doesn't seem to be
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 1398--1407
\OT1/cmtt/m/n/12 doing much for us anyway.. but it is, because you'll remember 
that we used the value
 []

[28]
Overfull \hbox (11.91006pt too wide) in paragraph at lines 1408--1413
[]\OT1/cmtt/m/n/12 In this way we can guarantee that not only is the simulation
 processing events in
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 1408--1413
\OT1/cmtt/m/n/12 order through reverse computation, but also that the simulatio
n will be deterministic.
 []


Overfull \hbox (43.68527pt too wide) in paragraph at lines 1408--1413
\OT1/cmtt/m/n/12 If your simulation is not deterministic, then it is worthless 
because it will not produce
 []


Overfull \hbox (56.03528pt too wide) in paragraph at lines 1415--1421
\OT1/cmtt/m/n/12 So at this point there is only one remaining step to complete,
 and it is the most important
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 1415--1421
\OT1/cmtt/m/n/12 step, statistic collection. In the application PCS we define a
 final state handler
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1415--1421
\OT1/cmtt/m/n/12 to complete this task, then call our own functions to compute 
the overall statistics
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 1415--1421
\OT1/cmtt/m/n/12 for the simulation run. Here we simply fill in our global stru
ct called TwAppStats
 []


Overfull \hbox (11.91006pt too wide) in paragraph at lines 1435--1439
[]\OT1/cmtt/m/n/12 Then we call our application-specific statistic computation 
function(s) and print
 []


Overfull \hbox (11.08125pt too wide) in paragraph at lines 1435--1439
\OT1/cmtt/m/n/12 out the statistics as you saw at the end of the main function,
 after tw[]run(). Then
 []


Overfull \hbox (48.93665pt too wide) in paragraph at lines 1442--1444
\OT1/cmr/bx/n/12 User Set Vari-ables: \OT1/cmtt/m/n/12 The following set of var
iables are set by the application at start-up. 
 []

LaTeX Font Info:    Try loading font information for OMS+cmtt on input line 144
6.
LaTeX Font Info:    No file OMScmtt.fd. on input line 1446.

LaTeX Font Warning: Font shape `OMS/cmtt/m/n' undefined
(Font)              using `OMS/cmsy/m/n' instead
(Font)              for symbol `textbullet' on input line 1446.


Overfull \hbox (17.24963pt too wide) in paragraph at lines 1446--1449
[]\OT1/cmr/bx/n/12 g[]tw[]ts[]end \OT1/cmtt/m/n/12 is a end time of the simulat
ion specified as a floating point number
 []


Overfull \hbox (36.00995pt too wide) in paragraph at lines 1446--1449
\OT1/cmtt/m/n/12 (64 bit precision). This must be set for all (parallel or sequ
ential) simulations.
 []


Overfull \hbox (41.17992pt too wide) in paragraph at lines 1450--1453
[]\OT1/cmr/bx/n/12 g[]tw[]mblock \OT1/cmtt/m/n/12 is the number of events proce
ssed without going to top of the scheduler
 []


Overfull \hbox (24.03476pt too wide) in paragraph at lines 1450--1453
\OT1/cmtt/m/n/12 loop. This variable only has meaning when the optimistic sched
uler is used. \OT1/cmtt/m/it/12 The
 []


Overfull \hbox (61.47603pt too wide) in paragraph at lines 1454--1460
[]\OT1/cmr/bx/n/12 g[]tw[]gvt[]interval \OT1/cmtt/m/n/12 is the number of times
 though the main scheduler loop before computing
 []


Overfull \hbox (14.02693pt too wide) in paragraph at lines 1454--1460
\OT1/cmtt/m/n/12 Global Virtual Time (GVT). It combined with the previous g[]tw
[]mblock control the
 []


Overfull \hbox (23.65994pt too wide) in paragraph at lines 1454--1460
\OT1/cmtt/m/n/12 amount of time or number of events processed between successiv
e GVT calculations.
 []


Overfull \hbox (17.48494pt too wide) in paragraph at lines 1454--1460
\OT1/cmtt/m/n/12 This variable is only used when the optimistic/parallel event 
scheduler is used.
 []

[29]
Overfull \hbox (42.20267pt too wide) in paragraph at lines 1461--1474
[]\OT1/cmr/bx/n/12 g[]tw[]events[]per[]pe \OT1/cmtt/m/n/12 is the number events
 allocated to each processor. Each processor
 []


Overfull \hbox (54.53496pt too wide) in paragraph at lines 1461--1474
\OT1/cmtt/m/n/12 has it own pool of event memory is manages. For sequential exe
cution, the application
 []


Overfull \hbox (42.18495pt too wide) in paragraph at lines 1461--1474
\OT1/cmtt/m/n/12 must allocate enough events such that the maximum event popula
tion of the simulation
 []


Overfull \hbox (60.70996pt too wide) in paragraph at lines 1461--1474
\OT1/cmtt/m/n/12 model can be supported. Typically this is just equal to the nu
mber of events scheduled
 []


Overfull \hbox (29.83495pt too wide) in paragraph at lines 1461--1474
\OT1/cmtt/m/n/12 at start-up multiplied by the number of LPs. For parallel exec
ution, extra memory
 []


Overfull \hbox (42.18495pt too wide) in paragraph at lines 1461--1474
\OT1/cmtt/m/n/12 is required over what the sequential requires, but only slight
ly more. We recommend
 []


Overfull \hbox (40.96889pt too wide) in paragraph at lines 1461--1474
\OT1/cmr/m/n/12 2[] \OMS/cmtt/m/n/12 ^^C []$ \OT1/cmtt/m/n/12 as the amount ext
ra. See [[]] for a more complete discussion
 []


Overfull \hbox (11.30994pt too wide) in paragraph at lines 1461--1474
\OT1/cmtt/m/n/12 as to how we derived this rule of thumb. Note, this paper is i
ncluded with the
 []


Overfull \hbox (8.08463pt too wide) in paragraph at lines 1475--1479
[]\OT1/cmr/bx/n/12 g[]tw[]nRNG[]per[]lp: \OT1/cmtt/m/n/12 User set variable tha
t contains the number of RNGs per LP.
 []


Overfull \hbox (32.5836pt too wide) in paragraph at lines 1475--1479
\OT1/cmtt/m/n/12 This is used to support multiple RNGs per LP. \OT1/cmtt/m/it/1
2 The default value is 1\OT1/cmtt/m/n/12 . See section
 []


Overfull \hbox (19.99742pt too wide) in paragraph at lines 1486--1488
[]\OT1/cmr/bx/n/12 main()\OT1/cmtt/m/n/12 : the application model must write it
s own main function, inside of which
 []


Overfull \hbox (29.83495pt too wide) in paragraph at lines 1489--1493
\OT1/cmtt/m/n/12 the system. It requires the application to provide: number of 
processors, number
 []


Overfull \hbox (68.03383pt too wide) in paragraph at lines 1494--1499
[]\OT1/cmr/bx/n/12 tw[]run(void)\OT1/cmtt/m/n/12 : Once all all system initiali
zation and LP/KP/PE mappings are established,
 []


Overfull \hbox (79.23497pt too wide) in paragraph at lines 1494--1499
\OT1/cmtt/m/n/12 this functions transfers control to the simulation engine and 
completes the initialization
 []


Overfull \hbox (5.13493pt too wide) in paragraph at lines 1494--1499
\OT1/cmtt/m/n/12 process and then executes the simulation. The simulation run i
s complete when
 []


Overfull \hbox (6.92961pt too wide) in paragraph at lines 1500--1503
[]\OT1/cmr/bx/n/12 tw[]end(void)\OT1/cmtt/m/n/12 : This function computes all t
he ROSS specific summary statistics
 []


Overfull \hbox (17.48494pt too wide) in paragraph at lines 1500--1503
\OT1/cmtt/m/n/12 and outputs any model statistics as well that where not alread
y printed from the
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 1505--1508
\OT1/cmtt/m/n/12 to schedule events into the future and are the core set of rou
tines used to construct
 []


Overfull \hbox (23.65994pt too wide) in paragraph at lines 1510--1516
\OT1/cmtt/m/n/12 allocates a new event buffer and fills in the destination LP, 
amount of time into
 []


Overfull \hbox (5.13493pt too wide) in paragraph at lines 1510--1516
\OT1/cmtt/m/n/12 the future and source LP information. PLEASE NOTE, THE TIME IS
 AMOUNT OF TIME
 []


Overfull \hbox (23.65994pt too wide) in paragraph at lines 1510--1516
\OT1/cmtt/m/n/12 INTO THE FUTURE FROM TIME NOW. THUS, IT IS A RELATIVE TIME OR 
OFFSET TIME AND NOT
 []


Overfull \hbox (8.28142pt too wide) in paragraph at lines 1517--1520
[]\OT1/cmr/bx/n/12 extern void *tw[]event[]data(tw[]event * event)\OT1/cmtt/m/n
/12 : given an pointer to an event from
 []


Overfull \hbox (2.14114pt too wide) in paragraph at lines 1521--1525
[]\OT1/cmr/bx/n/12 extern void tw[]event[]send(tw[]event * event)\OT1/cmtt/m/n/
12 : given an pointer to an event from
 []


Overfull \hbox (1.67693pt too wide) in paragraph at lines 1521--1525
\OT1/cmtt/m/n/12 tw[]new[]event and its data portion is been appropriately fill
ed in, schedule or
 []


Overfull \hbox (29.83495pt too wide) in paragraph at lines 1521--1525
\OT1/cmtt/m/n/12 send that event into the future at the specified time to the s
pecified destination
 []

[30]
Overfull \hbox (16.9829pt too wide) in paragraph at lines 1526--1528
[]\OT1/cmr/bx/n/12 extern tw[]stime tw[]now(tw[]lp * lp)\OT1/cmtt/m/n/12 : give
n a pointer to an LP, return the current
 []


Overfull \hbox (3.40593pt too wide) in paragraph at lines 1529--1540
\OT1/cmtt/m/n/12 ROSS systems. The TW[]LOC is a macro that will automatically s
how which SOURCE
 []


Overfull \hbox (23.65994pt too wide) in paragraph at lines 1529--1540
\OT1/cmtt/m/n/12 CODE file and LINE # within that file as to where the error oc
curred. The string
 []


Overfull \hbox (5.13493pt too wide) in paragraph at lines 1529--1540
\OT1/cmtt/m/n/12 denotes what the error is. PLEASE NOTE, THIS FUNCTION SHOULD N
OT BE USED WHEN
 []


Overfull \hbox (66.88496pt too wide) in paragraph at lines 1529--1540
\OT1/cmtt/m/n/12 OPTIMISTIC/PARALLEL EXECUTION IS TURNED ON, AS ERRORS CAN OCCU
R IN OPTIMISTIC PROCESSING
 []


Overfull \hbox (11.30994pt too wide) in paragraph at lines 1529--1540
\OT1/cmtt/m/n/12 WHICH ARE LATER ROLLED BACK. For sequential models only, it is
 fine to directly
 []


Overfull \hbox (17.48494pt too wide) in paragraph at lines 1529--1540
\OT1/cmtt/m/n/12 use this function in the simulation model code or in cases in 
parallel execution
 []


Overfull \hbox (11.30994pt too wide) in paragraph at lines 1529--1540
\OT1/cmtt/m/n/12 where you know there is an error which could not have been cau
sed by optimistic
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 1619--1627
\OT1/cmtt/m/n/12 The base uniform RNG is based on L'Ecuyer's Combined Linear Co
ngruential Generator [[]].
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 1619--1627
\OT1/cmtt/m/n/12 For all RNG functions, the LP identifier (lpid) is used to det
ermine which set of seeds
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1619--1627
\OT1/cmtt/m/n/12 is to be used. In this simulator engine, each LP is given its 
own set of seeds to
 []


Overfull \hbox (9.16031pt too wide) in paragraph at lines 1619--1627
\OT1/cmtt/m/n/12 prevent correlations among seeds. The seeds are approximately 
$\OT1/cmr/m/n/12 2[]$ \OT1/cmtt/m/n/12 calls apart. The
 []


Overfull \hbox (13.41037pt too wide) in paragraph at lines 1619--1627
\OT1/cmtt/m/n/12 overall period of this generator is $\OT1/cmr/m/n/12 2[]$\OT1/
cmtt/m/n/12 . The distributions where developed based on
 []


Overfull \hbox (5.73506pt too wide) in paragraph at lines 1628--1633
[]\OT1/cmtt/m/n/12 The RNG seeds are initialized based on a seed jumping techni
que that is possible
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 1628--1633
\OT1/cmtt/m/n/12 with this generator. The technique is extremely fast. It is mu
ch faster than reading
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1628--1633
\OT1/cmtt/m/n/12 a file of pre-generated seeds. Additionally, when you want to 
have 100K or even 1
 []


Overfull \hbox (8.08463pt too wide) in paragraph at lines 1635--1638
[]\OT1/cmr/bx/n/12 g[]tw[]nRNG[]per[]lp: \OT1/cmtt/m/n/12 User set variable tha
t contains the number of RNGs per LP.
 []


Overfull \hbox (36.00995pt too wide) in paragraph at lines 1639--1643
\OT1/cmtt/m/n/12 random number between the ranges of low to high inclusive. In 
the case of multiple
 []


Overfull \hbox (16.74393pt too wide) in paragraph at lines 1639--1643
\OT1/cmtt/m/n/12 RNGs per LP, you index the RNG with the LP id times the g[]tw[
]nRNG[]per[]lp plus the
 []


Overfull \hbox (12.65286pt too wide) in paragraph at lines 1644--1647
\OT1/cmtt/m/n/12 number of successes (i.e., less than probability $\OML/cmm/m/i
t/12 P$\OT1/cmtt/m/n/12 ) of the $\OML/cmm/m/it/12 N$ \OT1/cmtt/m/n/12 Bernoull
i trials. 
 []

[31]
Overfull \hbox (20.51543pt too wide) in paragraph at lines 1656--1659
\OT1/cmtt/m/n/12 of trials up to and including the first success (i.e., less th
an probability $\OML/cmm/m/it/12 P$\OT1/cmtt/m/n/12 ). 
 []


Overfull \hbox (3.34541pt too wide) in paragraph at lines 1660--1664
[]\OT1/cmr/bx/n/12 extern dou-ble tw[]rand[]normal01(tw[]rng[]stream *g)\OT1/cm
tt/m/n/12 : returns a \OT1/cmtt/m/it/12 unit \OT1/cmtt/m/n/12 or standard
 []


Overfull \hbox (5.13493pt too wide) in paragraph at lines 1660--1664
\OT1/cmtt/m/n/12 normal distributed random number, where the mean and standard 
deviation of the
 []


Overfull \hbox (23.43062pt too wide) in paragraph at lines 1665--1668
[]\OT1/cmr/bx/n/12 extern dou-ble tw[]rand[]normal[]sd(tw[]rng[]stream *g, dou-
ble Mu, dou-ble Sd)\OT1/cmtt/m/n/12 : returns
 []


Overfull \hbox (36.79312pt too wide) in paragraph at lines 1665--1668
\OT1/cmtt/m/n/12 a normal distributed random number where the mean is $\OML/cmm
/m/it/12 Mu$ \OT1/cmtt/m/n/12 and the standard deviation
 []


Overfull \hbox (54.53496pt too wide) in paragraph at lines 1669--1674
\OT1/cmtt/m/n/12 returns a Pareto distributed random number of a particular sha
pe. The scale parameter
 []


Overfull \hbox (11.30994pt too wide) in paragraph at lines 1669--1674
\OT1/cmtt/m/n/12 is used to adjust it to fit a particular mean. The mean of the
 distribution is
 []


Overfull \hbox (9.37794pt too wide) in paragraph at lines 1675--1678
\OT1/cmtt/m/n/12 number of arrivals in a given time period $\OML/cmm/m/it/12 t$
 \OT1/cmtt/m/n/12 assuming some average arrival rate,
 []


Overfull \hbox (5.13493pt too wide) in paragraph at lines 1679--1686
\OT1/cmtt/m/n/12 or undo the uniform part of the RNG exactly one call. Thus, fo
r distributions
 []


Overfull \hbox (11.30994pt too wide) in paragraph at lines 1679--1686
\OT1/cmtt/m/n/12 that make multiple calls to the RNG, you will need to save tha
t information and
 []


Overfull \hbox (23.65994pt too wide) in paragraph at lines 1679--1686
\OT1/cmtt/m/n/12 call this function that many times in order to restore the RNG
 seeds to the state
 []


Overfull \hbox (29.83495pt too wide) in paragraph at lines 1679--1686
\OT1/cmtt/m/n/12 prior to the execution of this event. This routine is to only 
be used for reverse
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1689--1692
\OT1/cmtt/m/n/12 ROSS supports two priority queues: Calendar Queue and Splay Tr
ee. In a nutshell,
 []


Overfull \hbox (99.2603pt too wide) in paragraph at lines 1689--1692
\OT1/cmtt/m/n/12 you should used the Calendar Queue if the simulation model exh
ibits the following characteristics: 
 []


Overfull \hbox (18.08507pt too wide) in paragraph at lines 1700--1707
[]\OT1/cmtt/m/n/12 The simulation model fails to meet any of these characterist
ics, there is a strong
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 1700--1707
\OT1/cmtt/m/n/12 chance the Calendar Queue will shift into running its ``worse 
case'' performance range,
 []


Overfull \hbox (38.26888pt too wide) in paragraph at lines 1700--1707
\OT1/cmtt/m/n/12 which is $\OML/cmm/m/it/12 O\OT1/cmr/m/n/12 (\OML/cmm/m/it/12 
n\OT1/cmr/m/n/12 )$ \OT1/cmtt/m/n/12 for enqueue and dequeue operations. It's n
ormal ``best case'' performance
 []


Overfull \hbox (13.09666pt too wide) in paragraph at lines 1700--1707
\OT1/cmtt/m/n/12 complexity is $\OML/cmm/m/it/12 O\OT1/cmr/m/n/12 (1)$\OT1/cmtt
/m/n/12 . The Splay-Tree has a rock solid $\OML/cmm/m/it/12 O\OT1/cmr/m/n/12 (\
OML/cmm/m/it/12 log\OT1/cmr/m/n/12 (\OML/cmm/m/it/12 n\OT1/cmr/m/n/12 ))$ \OT1/
cmtt/m/n/12 performance complexity
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 1700--1707
\OT1/cmtt/m/n/12 for enqueue and dequeue operations and thus should be used in 
cases where the Calendar
 []


Overfull \hbox (9.59808pt too wide) in paragraph at lines 1708--1712
[]\OT1/cmtt/m/n/12 To configure which queue is used, modify the Makefile in the
 $\OML/cmm/m/it/12 src$ \OT1/cmtt/m/n/12 directory of the
 []


Overfull \hbox (9.98593pt too wide) in paragraph at lines 1708--1712
\OT1/cmtt/m/n/12 ROSS distribution. Here, set the $\OML/cmm/m/it/12 QUEUE$ \OT1
/cmtt/m/n/12 variable to either: queue-calendar.o for
 []

[32]
Overfull \hbox (48.96008pt too wide) in paragraph at lines 1713--1715
[]\OT1/cmtt/m/n/12 For a detailed performance study on different queue algorith
ms, we refer the interested
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 1720--1722
\OT1/cmtt/m/n/12 The following are typical errors or problems that could be gen
erated from inside of
 []


Overfull \hbox (59.70578pt too wide) in paragraph at lines 1724--1732
[]\OT1/cmr/bx/n/12 Core Dumps\OT1/cmtt/m/n/12 : The most common error is that y
our application will yield a segmentation
 []


Overfull \hbox (29.83495pt too wide) in paragraph at lines 1724--1732
\OT1/cmtt/m/n/12 fault/core dump. The cause of such an error usually has do wit
h something in your
 []


Overfull \hbox (11.30994pt too wide) in paragraph at lines 1724--1732
\OT1/cmtt/m/n/12 application. Either initialization is not correct or insuffici
ent event memory
 []


Overfull \hbox (54.53496pt too wide) in paragraph at lines 1724--1732
\OT1/cmtt/m/n/12 has been allocated. In any case, the best course of action is 
to put your application
 []


Overfull \hbox (17.48494pt too wide) in paragraph at lines 1724--1732
\OT1/cmtt/m/n/12 under a debugger (i.e., gdb) and see where the fault lies and 
then back track it
 []


Overfull \hbox (17.74739pt too wide) in paragraph at lines 1733--1740
[]\OT1/cmr/bx/n/12 Insufficient Event Mem-ory\OT1/cmtt/m/n/12 . This error only
 occurs when the sequential scheduler
 []


Overfull \hbox (5.13493pt too wide) in paragraph at lines 1733--1740
\OT1/cmtt/m/n/12 is used. Here, the simulation model has exhausted event memory
. The solution
 []


Overfull \hbox (88.37395pt too wide) in paragraph at lines 1733--1740
\OT1/cmtt/m/n/12 is to allocate more event memory by increasing g[]tw[]events[]
per[]pe or g[]tw[]timer[]reserve[]per[]pe
 []


Overfull \hbox (11.30994pt too wide) in paragraph at lines 1741--1751
\OT1/cmtt/m/n/12 execution is turned on. In this case, the simulation model has
 reached a state
 []


Overfull \hbox (60.70996pt too wide) in paragraph at lines 1741--1751
\OT1/cmtt/m/n/12 where it can no longer make progress and thus the Global Virtu
al Time (GVT) computation
 []


Overfull \hbox (98.74797pt too wide) in paragraph at lines 1741--1751
\OT1/cmtt/m/n/12 is no longer advancing. The solution here is to increase eithe
r or both the g[]tw[]gvt[]interval
 []


Overfull \hbox (1.67693pt too wide) in paragraph at lines 1741--1751
\OT1/cmtt/m/n/12 and g[]tw[]mblock parameters to allow more events to be proces
sed per GVT epoch.
 []


Overfull \hbox (66.88496pt too wide) in paragraph at lines 1741--1751
\OT1/cmtt/m/n/12 Additionally, you may need to provide more optimistic memory e
vent buffers by increasing
 []


Overfull \hbox (29.09393pt too wide) in paragraph at lines 1741--1751
\OT1/cmtt/m/n/12 g[]tw[]events[]per[]pe. If both of these fail, start looking a
t your simulation model. 
 []


Overfull \hbox (23.65994pt too wide) in paragraph at lines 1752--1760
\OT1/cmtt/m/n/12 possible even if they do not correlate to the physical system 
being modeled. The
 []


Overfull \hbox (66.88496pt too wide) in paragraph at lines 1752--1760
\OT1/cmtt/m/n/12 proper solution to handling simultaneous events is to simulate
 ALL possible permutations
 []


Overfull \hbox (5.13493pt too wide) in paragraph at lines 1752--1760
\OT1/cmtt/m/n/12 of event orderings and take an average of the outcome. As such
, ROSS does not
 []


Overfull \hbox (60.70996pt too wide) in paragraph at lines 1752--1760
\OT1/cmtt/m/n/12 do anything special to handle tie events. That must be handled
 within the application.
 []


Overfull \hbox (23.65994pt too wide) in paragraph at lines 1752--1760
\OT1/cmtt/m/n/12 Please note, that having many tie events could result in the p
reviously mentioned
 []


Overfull \hbox (23.65994pt too wide) in paragraph at lines 1765--1770
\OT1/cmtt/m/n/12 size of the systems small so you can trace the event flow by h
and. When you have
 []


Overfull \hbox (29.83495pt too wide) in paragraph at lines 1765--1770
\OT1/cmtt/m/n/12 even 1000s of events or 100s of LPs/simulation objects, it bec
ome to much and bugs
 []

[33]
Overfull \hbox (11.61401pt too wide) in paragraph at lines 1771--1774
[]\OT1/cmr/bx/n/12 Start with Se-quen-tial Ex-e-cu-tion First\OT1/cmtt/m/n/12 :
 Build your model for sequential execution
 []


Overfull \hbox (73.05997pt too wide) in paragraph at lines 1771--1774
\OT1/cmtt/m/n/12 only first. Make sure it yields correct results across a wide 
variety of configurations. 
 []


Overfull \hbox (6.04039pt too wide) in paragraph at lines 1775--1781
[]\OT1/cmr/bx/n/12 Become Pro-fi-cient with a De-bug-ger\OT1/cmtt/m/n/12 : The 
GNU debugger (GDB) or the Data Display
 []


Overfull \hbox (23.65994pt too wide) in paragraph at lines 1775--1781
\OT1/cmtt/m/n/12 Debugger (front end to GDB) is recommended. As with any comple
x software system,
 []


Overfull \hbox (36.00995pt too wide) in paragraph at lines 1775--1781
\OT1/cmtt/m/n/12 a debugger is an invaluable tool. However, if you are trying t
o find an event-flow
 []


Overfull \hbox (29.83495pt too wide) in paragraph at lines 1775--1781
\OT1/cmtt/m/n/12 logic error, the debugger is probably not the best method. Log
 files are probably
 []


Overfull \hbox (36.00995pt too wide) in paragraph at lines 1782--1786
\OT1/cmtt/m/n/12 in a simulation model is to create LP-specific log files. This
 will allow complete
 []


Overfull \hbox (11.30994pt too wide) in paragraph at lines 1782--1786
\OT1/cmtt/m/n/12 LP-event flows to be captured. It is advisable for the develop
er to append the
 []


Overfull \hbox (3.58289pt too wide) in paragraph at lines 1787--1793
[]\OT1/cmr/bx/n/12 Use of locks dur-ing de-bug-ging: \OT1/cmtt/m/n/12 ROSS has 
a debug lock, \OT1/cmr/bx/n/12 g[]tw[]debug[]lck\OT1/cmtt/m/n/12 , that can
 []


Overfull \hbox (23.65994pt too wide) in paragraph at lines 1787--1793
\OT1/cmtt/m/n/12 be used in the application code to provide a debugging critica
l section. The can
 []


Overfull \hbox (66.88496pt too wide) in paragraph at lines 1787--1793
\OT1/cmtt/m/n/12 be used to provide a global counter of certain kinds of activi
ties across all processors
 []


Overfull \hbox (36.00995pt too wide) in paragraph at lines 1787--1793
\OT1/cmtt/m/n/12 as well as used to ensure printf output appears to a terminal 
in the correct order. 
 []


Overfull \hbox (16.31404pt too wide) in paragraph at lines 1794--1800
[]\OT1/cmr/bx/n/12 Forced seg-men-ta-tion faults: \OT1/cmtt/m/n/12 A final tech
nique we have found useful is to declare
 []


Overfull \hbox (73.05997pt too wide) in paragraph at lines 1794--1800
\OT1/cmtt/m/n/12 a pointer variable and set it to NULL. When an error condition
 is found, just dereference
 []


Overfull \hbox (5.13493pt too wide) in paragraph at lines 1794--1800
\OT1/cmtt/m/n/12 the pointer variable using the * operator and force a segmenta
tion fault. The
 []


Overfull \hbox (5.13493pt too wide) in paragraph at lines 1794--1800
\OT1/cmtt/m/n/12 debugger will capture this point and allow you to start debugg
ing at the point
 []

[34]
File: rn_combines.ps Graphic file (type eps)
 <rn_combines.ps>
Overfull \hbox (24.26007pt too wide) in paragraph at lines 1816--1820
[]\OT1/cmtt/m/n/12 The ROSS.Net network simulation framework supports the study
 of large-scale network
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1816--1820
\OT1/cmtt/m/n/12 models on High Performance Computing (HPC) platforms. This Use
r's Guide serves to
 []


Overfull \hbox (30.43507pt too wide) in paragraph at lines 1821--1827
[]\OT1/cmtt/m/n/12 As shown in Figure 1[], ROSS.Net aims to bring together four
 major areas of networking
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 1821--1827
\OT1/cmtt/m/n/12 research: simulation, protocol design, network modeling and me
asurement and experiment
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 1821--1827
\OT1/cmtt/m/n/12 design. The major components of ROSS.Net are an experiment des
ign framework, a parallel
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 1821--1827
\OT1/cmtt/m/n/12 discrete event simulator, and efficient models for network pro
tocols and layering [[],
 []


Overfull \hbox (30.43507pt too wide) in paragraph at lines 1828--1844
[]\OT1/cmtt/m/n/12 ROSS.Net incorporates the Unified Search Framework (USF) for
 performing optimization
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 1828--1844
\OT1/cmtt/m/n/12 over the range of ROSS.Net parameters for the study of large-s
cale networks [[]]. USF
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 1828--1844
\OT1/cmtt/m/n/12 automates the process of experiment design and analysis. For s
imulation, at the heart
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 1828--1844
\OT1/cmtt/m/n/12 of ROSS.Net is Rensselaer's Optimistic Simulation System (ROSS
). ROSS is a parallel
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1828--1844
\OT1/cmtt/m/n/12 discrete event, parallel execution simulation engine that has 
been shown to scale to
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 1828--1844
\OT1/cmtt/m/n/12 tens of thousands of processors for synthetic benchmarks, as w
ell as realistic models
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1828--1844
\OT1/cmtt/m/n/12 of mobility and waveforms for mobile ad-hoc networks [[]]. Run
ning on top of ROSS is
 []


Overfull \hbox (56.03528pt too wide) in paragraph at lines 1828--1844
\OT1/cmtt/m/n/12 the ROSS.Net simulation model. The ROSS.Net simulation model p
rovides efficient mechanisms
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1828--1844
\OT1/cmtt/m/n/12 for layering multiple network protocol models, multiplexing pa
cket streams, packet
 []


Overfull \hbox (49.86028pt too wide) in paragraph at lines 1828--1844
\OT1/cmtt/m/n/12 encapsulation, and an API interface for inter-layer communicat
ions. ROSS.Net incorporates
 []


Overfull \hbox (68.38528pt too wide) in paragraph at lines 1828--1844
\OT1/cmtt/m/n/12 a collection of protocol libraries (e.g.: OSPFv2, TCP-Tahoe [[
]], UDP, IPv4, Multicast/IPv4,
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 1828--1844
\OT1/cmtt/m/n/12 etc). It allows for the rapid creation and examination of new 
and incremental protocol
 []

[35]
File: rn_architecture.ps Graphic file (type eps)
 <rn_architecture.ps>
Overfull \hbox (42.78508pt too wide) in paragraph at lines 1857--1867
[]\OT1/cmtt/m/n/12 Figure 2[] attempts to illustrate the modular nature of ROSS
.Net, and how this framework
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1857--1867
\OT1/cmtt/m/n/12 defines the trade-off between fidelity and scalability. At the
 bottom of 2a, ROSS
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 1857--1867
\OT1/cmtt/m/n/12 forms the basis for the framework, providing mechanisms for ef
ficient, large-scale,
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 1857--1867
\OT1/cmtt/m/n/12 parallel discrete event simulation. The ROSS.Net models includ
e the ROSS.Net model
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 1857--1867
\OT1/cmtt/m/n/12 itself as well as network protocol models. The ROSS.Net model 
provides a framework
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 1857--1867
\OT1/cmtt/m/n/12 for wrapping and layering network protocol models. All constru
cts in ROSS are ROSS.Net
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 1857--1867
\OT1/cmtt/m/n/12 model structures, and ROSS.Net is responsible for providing a 
functional API interface
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 1857--1867
\OT1/cmtt/m/n/12 to the network protocol models to facilitate construction of n
etwork-specific elements
 []


Overfull \hbox (30.43507pt too wide) in paragraph at lines 1878--1880
[]\OT1/cmtt/m/n/12 Each definition is passed to ROSS.Net as a separate XML file
, and ROSS.Net does some
 []

[36]
Overfull \hbox (18.98526pt too wide) in paragraph at lines 1883--1887
\OT1/cmtt/m/n/12 The network topology defines networking constructs such as aut
onomous systems (ASes),
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1883--1887
\OT1/cmtt/m/n/12 areas, subnets and machines (or nodes). In addition, the netwo
rk topology defines
 []


Overfull \hbox (28.73796pt too wide) in paragraph at lines 1907--1907
[]                    \OT1/cmtt/m/n/10.95 <link src='0' addr='3' bandwidth='155
000000' delay='0.0015' status='up'/>[] 
 []


Overfull \hbox (22.98927pt too wide) in paragraph at lines 1907--1907
[]                    \OT1/cmtt/m/n/10.95 <link src='0' addr='6' bandwidth='450
00000' delay='0.0015' status='up'/>[] 
 []


Overfull \hbox (61.31009pt too wide) in paragraph at lines 1909--1914
[]\OT1/cmtt/m/n/12 The portion of the snippet highlighted as red text is model 
defined XML for configuration
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 1909--1914
\OT1/cmtt/m/n/12 of this element in the ospf model. ROSS.Net builds a a data st
ructure representing
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1909--1914
\OT1/cmtt/m/n/12 the network from the network topology file using the as, area,
 subnet, node and link
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1909--1914
\OT1/cmtt/m/n/12 XML elements. This data structure is accessible through the fu
nctional API provided
 []


Overfull \hbox (11.91006pt too wide) in paragraph at lines 1933--1938
[]\OT1/cmtt/m/n/12 One example of the use of these functions is in the OSPFv2 a
nd IPv2 models. Each
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1933--1938
\OT1/cmtt/m/n/12 of these models computes routing tables for a given node in th
e network based on the
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 1933--1938
\OT1/cmtt/m/n/12 topology. These protocols traverse ROSS.Net's global data stru
cture to generate routing
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 1933--1938
\OT1/cmtt/m/n/12 tables. ROSS.Net provides functions for updating and retrievin
g routing table entries: 
 []

[37]
Overfull \hbox (0.46025pt too wide) in paragraph at lines 1951--1959
\OT1/cmtt/m/n/12 The network traffic topology describes the traffic profile and
 connections between
 []


Overfull \hbox (49.86028pt too wide) in paragraph at lines 1951--1959
\OT1/cmtt/m/n/12 network nodes. An example would be a connection between an HTT
P client (Internet browser)
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 1951--1959
\OT1/cmtt/m/n/12 and server (website). The traffic topology should describe whe
n the browser connects
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 1951--1959
\OT1/cmtt/m/n/12 to website, what files are requested (corresponding to GET, PU
T, POST) and when the
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 1951--1959
\OT1/cmtt/m/n/12 requests are made during the simulation. Existing ROSS.Net net
work protocol models
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 1951--1959
\OT1/cmtt/m/n/12 simply require connection definitions between clients and serv
ers, and so the defined
 []


Overfull \hbox (24.26007pt too wide) in paragraph at lines 1966--1969
[]\OT1/cmtt/m/n/12 Given the basic nature of the current traffic API, the conne
ctions can be specified
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1966--1969
\OT1/cmtt/m/n/12 within the rossnet element in the network topology definition 
file, or in a separate
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1972--1975
\OT1/cmtt/m/n/12 The dynamic network link topology describes the dynamic link t
opology that can occur
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1972--1975
\OT1/cmtt/m/n/12 over the simulation runtime. For example, links may go up / do
wn at various times
 []


Overfull \hbox (61.31009pt too wide) in paragraph at lines 1985--1989
[]\OT1/cmtt/m/n/12 The status element indicates that the link from src to addr 
dynamically updates according
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1985--1989
\OT1/cmtt/m/n/12 to the function indicated by mode. The only mode currently sup
ported is "once", and
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 1993--2000
\OT1/cmtt/m/n/12 The ROSS memory library provides a unique capability for model
s built in ROSS. For
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1993--2000
\OT1/cmtt/m/n/12 performance reasons, models never allocate or free memory duri
ng runtime. First and
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 1993--2000
\OT1/cmtt/m/n/12 foremost, these operations would be irrevocable during reverse
 computation. Second,
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 1993--2000
\OT1/cmtt/m/n/12 the impact on calling these operations can make the simulation
 unstable and perform
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 1993--2000
\OT1/cmtt/m/n/12 poorly. The preferred approach is to statically allocate all o
f the memory the model
 []

[38]
Overfull \hbox (18.08507pt too wide) in paragraph at lines 2001--2003
[]\OT1/cmtt/m/n/12 Memory buffers are statically allocated during simulation in
itialization using the
 []


Overfull \hbox (5.74321pt too wide) in paragraph at lines 2008--2008
[]     \OT1/cmtt/m/n/10.95 g_tcp_fd = tw_kp_memory_init(tw_getkp(i), 10000 / g_
tw_nkp, sizeof(tcp_message), 1);[] 
 []


Overfull \hbox (18.08507pt too wide) in paragraph at lines 2011--2013
[]\OT1/cmtt/m/n/12 The call returns a file descriptor that is then used to sign
ify the type of memory
 []


Overfull \hbox (36.61008pt too wide) in paragraph at lines 2014--2022
[]\OT1/cmtt/m/n/12 The unique requirements of reverse computation caused us to 
generate a memory library
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 2014--2022
\OT1/cmtt/m/n/12 in ROSS that facilitates reverse computation of models. The li
brary provides functions
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 2014--2022
\OT1/cmtt/m/n/12 for allocation and deallocation of memory, and reversing these
 operations. Notionally,
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 2014--2022
\OT1/cmtt/m/n/12 the reverse computation of an allocation is to free the memory
. The reverse of a free
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 2014--2022
\OT1/cmtt/m/n/12 is an allocation of memory, with the data intact at the time o
f the free. ROSS handles
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 2014--2022
\OT1/cmtt/m/n/12 all of the issues related to allocation, deallocation, and fos
sil collection of memory
 []


Overfull \hbox (48.21907pt too wide) in paragraph at lines 2044--2049
[]\OT1/cmtt/m/n/12 The functions tw[]memory[]alloc and tw[]memory[]free are use
d during normal event processing
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2044--2049
\OT1/cmtt/m/n/12 to allocate and free memory buffers. During reverse computatio
n, these operations
 []


Overfull \hbox (18.24425pt too wide) in paragraph at lines 2044--2049
\OT1/cmtt/m/n/12 can be reversed by calling the []rc equivalents. Notice that c
alling tw[]memory[]free[]rc
 []


Overfull \hbox (11.16905pt too wide) in paragraph at lines 2050--2054
[]\OT1/cmtt/m/n/12 The library provides two helper functions, tw[]memory[]getsi
ze, tw[]memory[]data, that
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2050--2054
\OT1/cmtt/m/n/12 return the size of the memory buffer, and a pointer to the dat
a portion of the memory
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2050--2054
\OT1/cmtt/m/n/12 buffer, respectively. The data portion of the memory buffer is
 used by the model to
 []


Overfull \hbox (55.13509pt too wide) in paragraph at lines 2055--2062
[]\OT1/cmtt/m/n/12 Memory buffers may be attached to events, and the ROSS memor
y library provides functions
 []


Overfull \hbox (32.32326pt too wide) in paragraph at lines 2055--2062
\OT1/cmtt/m/n/12 to facilitate this feature. The functions tw[]event[]memory[]s
et and setfifo attach memory
 []


Overfull \hbox (44.67326pt too wide) in paragraph at lines 2055--2062
\OT1/cmtt/m/n/12 buffers to events. The function tw[]event[]memory[]get retriev
es memory buffers from events,
 []


Overfull \hbox (67.64427pt too wide) in paragraph at lines 2055--2062
\OT1/cmtt/m/n/12 and the function tw[]event[]memory[]get[]rc replaces buffers o
n events during reverse computation.
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 2055--2062
\OT1/cmtt/m/n/12 Notionally, there is no action to perform in computing the inv
erse of setting a buffer
 []

[39]
Overfull \hbox (11.91006pt too wide) in paragraph at lines 2063--2067
[]\OT1/cmtt/m/n/12 ROSS also provides a simple queue data structure for storing
 memory buffers in an
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2063--2067
\OT1/cmtt/m/n/12 LPs state. The following functions provide access to the queue
 data structure, and
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2063--2067
\OT1/cmtt/m/n/12 should provide the functionality to implement stacks, as well 
as a number of other
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 2084--2088
\OT1/cmtt/m/n/12 ROSS.Net is executed from the command line from a UNIX shell. 
The command line options
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2084--2088
\OT1/cmtt/m/n/12 can be found using the -help option. In addition, the options 
for manipulating the
 []

[40]
Overfull \hbox (0.79912pt too wide) in paragraph at lines 2125--2133
\OT1/cmtt/m/n/12 The \OT1/cmr/bx/n/12 Tools \OT1/cmtt/m/n/12 directory contains
 a repository of model configurations for execution in
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 2125--2133
\OT1/cmtt/m/n/12 ROSS.Net, and is located, aptly, in the tools/ subdirectory. T
he primary command line
 []


Overfull \hbox (74.56029pt too wide) in paragraph at lines 2125--2133
\OT1/cmtt/m/n/12 option for ROSS.Net is --scenario=value. The value specified h
ere indicates the sub-directory
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 2125--2133
\OT1/cmtt/m/n/12 to use in the tools/ directory where ROSS.Net will find all of
 the XML definition files.
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2125--2133
\OT1/cmtt/m/n/12 The network topology definition file must named the same as th
e tools sub-directory,
 []


Overfull \hbox (36.61008pt too wide) in paragraph at lines 2158--2161
[]\OT1/cmtt/m/n/12 In this example, the IPv4 protocol model reads /writes the f
ile ip.rt, which contains
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2158--2161
\OT1/cmtt/m/n/12 the routing tables for the nodes, and ROSS.Net will generate o
utput statistics for
 []


Overfull \hbox (55.13509pt too wide) in paragraph at lines 2162--2164
[]\OT1/cmtt/m/n/12 Other command line options come from ROSS, such as the simul
ation end time, --end=value. 
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 2167--2172
\OT1/cmtt/m/n/12 So you want to contribute a new model to the ROSS.Net framewor
k and test its operation
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 2167--2172
\OT1/cmtt/m/n/12 in the context of the existing network protocol models? Then y
ou need to do two things:
 []


Overfull \hbox (49.86028pt too wide) in paragraph at lines 2167--2172
\OT1/cmtt/m/n/12 i) develop a model and ii) hook the model into ROSS.Net framew
ork. The following sections
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 2175--2177
\OT1/cmtt/m/n/12 While models written in a variety of programming languages, we
 focus here on C. Models
 []

[41]
Overfull \hbox (79.8351pt too wide) in paragraph at lines 2188--2193
[]\OT1/cmtt/m/n/12 The first four functions are equivalent to functions in ROSS
, and handle the initialization,
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2188--2193
\OT1/cmtt/m/n/12 event processing, reverse event processing and finalization of
 LPs. The final three
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 2188--2193
\OT1/cmtt/m/n/12 functions are specific to ROSS.Net and are hooks into the mode
ls during the XML parsing
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2196--2203
\OT1/cmtt/m/n/12 This purpose of this function is to initialize the state assoc
iated with each LP. Per
 []


Overfull \hbox (49.86028pt too wide) in paragraph at lines 2196--2203
\OT1/cmtt/m/n/12 LP operations such as memory allocation, initial variable assi
gnment, etc. are performed.
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2196--2203
\OT1/cmtt/m/n/12 A critical function of the LP initialize function is to prime 
the system with events.
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 2196--2203
\OT1/cmtt/m/n/12 For example, an HTTP client LP may initiate a file transfer in
 this function. However,
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2196--2203
\OT1/cmtt/m/n/12 not all models create initial events. The IP model acts to for
ward IP packet events
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 2206--2210
\OT1/cmtt/m/n/12 The purpose of this function is to handle events passed into t
he model. Events coming
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2206--2210
\OT1/cmtt/m/n/12 into the model are specific to the model. The model must deter
mine the processing
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2206--2210
\OT1/cmtt/m/n/12 required for one or more event types, and event types are defi
ned by the individual
 []


Overfull \hbox (5.73506pt too wide) in paragraph at lines 2211--2217
[]\OT1/cmtt/m/n/12 In addition to normal event processing, the modeler must gen
erate code necessary
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2211--2217
\OT1/cmtt/m/n/12 for reverse computing the state of the LP. Typically this invo
lves setting a bit in
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2211--2217
\OT1/cmtt/m/n/12 the provided bitfield for branches taken and state-saving vari
ables into the event
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2211--2217
\OT1/cmtt/m/n/12 that contain destructive statements such as assignment. These 
code operations are
 []


Overfull \hbox (11.91006pt too wide) in paragraph at lines 2218--2227
[]\OT1/cmtt/m/n/12 Beyond handling model events, a model must handle events pot
entially being passed
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2218--2227
\OT1/cmtt/m/n/12 between layers. Each layer model should assume that events may
 come from above or
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2218--2227
\OT1/cmtt/m/n/12 below the current model and handle them appropriately. The TCP
 model handles events
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2218--2227
\OT1/cmtt/m/n/12 being passed down from the application layer. It properly gene
rates TCP packets that
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2218--2227
\OT1/cmtt/m/n/12 simulate fragmentation according to the semantics of TCP. The 
TCP model also handles
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2218--2227
\OT1/cmtt/m/n/12 events coming from below, such as the IP layer, ensuring that 
data coming in from the
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2218--2227
\OT1/cmtt/m/n/12 network is in order and unfragmented. When all of the requeste
d bytes are available,
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 2218--2227
\OT1/cmtt/m/n/12 the TCP model creates and sends a final event up to the layer 
above it, if any exists. 
 []

[42]
Overfull \hbox (11.91006pt too wide) in paragraph at lines 2228--2237
[]\OT1/cmtt/m/n/12 Models should operate under the assumption that layers above
 and below exist, but
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2228--2237
\OT1/cmtt/m/n/12 they should not require knowledge from the surrounding layers.
 When the TCP model
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2228--2237
\OT1/cmtt/m/n/12 receives a downstream message from a layer above it, it only r
equires the size of the
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2228--2237
\OT1/cmtt/m/n/12 data to determine the number of TCP packets to generate. The p
ointer to the data is
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2228--2237
\OT1/cmtt/m/n/12 then sent with the final TCP packet. When upstream events are 
received from layers
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2228--2237
\OT1/cmtt/m/n/12 below TCP, the model treats these as data packets or acknowled
gements. Both event
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 2228--2237
\OT1/cmtt/m/n/12 types are defined by the TCP layer, and handled appropriately.
 When a data transmission
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 2228--2237
\OT1/cmtt/m/n/12 operation is complete, the TCP model sends an upstream message
 to indicate completion. 
 []


Overfull \hbox (18.08507pt too wide) in paragraph at lines 2238--2244
[]\OT1/cmtt/m/n/12 ROSS.Net manages the protocol stack and determines delivery 
based on the direction
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2238--2244
\OT1/cmtt/m/n/12 of the event through the stack and the current model sending t
he event. When the top
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2238--2244
\OT1/cmtt/m/n/12 of the stack is reached, and a model sends an event up, ROSS.N
et reclaims the event
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2238--2244
\OT1/cmtt/m/n/12 (no processing occurs). When the bottom of the stack is reache
d and a model sends
 []


Overfull \hbox (43.68527pt too wide) in paragraph at lines 2247--2251
\OT1/cmtt/m/n/12 The purpose of this function is to reverse compute the state o
f an LP during the rollback
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 2247--2251
\OT1/cmtt/m/n/12 of an improperly processed event. Recall that the rollback mec
hanism is used to ensure
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2247--2251
\OT1/cmtt/m/n/12 that events are processed in timestamp order, and the ROSS opt
imistically executes
 []


Overfull \hbox (36.61008pt too wide) in paragraph at lines 2252--2257
[]\OT1/cmtt/m/n/12 Generating the reverse computation code is a manual process 
performed by the modeler.
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 2252--2257
\OT1/cmtt/m/n/12 The primary goal of this function is to restore the state of t
he LP prior to the current
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 2252--2257
\OT1/cmtt/m/n/12 events execution. The current event is passed into this functi
on in order to facilitate
 []


Overfull \hbox (36.61008pt too wide) in paragraph at lines 2258--2267
[]\OT1/cmtt/m/n/12 Reverse computation most frequently takes one of three forms
. Many operations deemed
 []


Overfull \hbox (49.86028pt too wide) in paragraph at lines 2258--2267
\OT1/cmtt/m/n/12 constructive can be directly reverse computed. For example, in
crementing a state variable
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 2258--2267
\OT1/cmtt/m/n/12 during the LP event handler is matched with decrement in the r
everse computation event
 []


Overfull \hbox (49.86028pt too wide) in paragraph at lines 2258--2267
\OT1/cmtt/m/n/12 handler. Operations deemed destructive, such as assignments or
 floating point operations,
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 2258--2267
\OT1/cmtt/m/n/12 must be state saved into the event during normal event handlin
g, and then the original
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 2258--2267
\OT1/cmtt/m/n/12 values restored via assignment during the reverse computation.
 Finally, the per-event
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2258--2267
\OT1/cmtt/m/n/12 bitfield can be used to determine the path taken through the c
ode during normal event
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2270--2274
\OT1/cmtt/m/n/12 The purpose of this function is to provide an opportunity for 
each LP to process and
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2270--2274
\OT1/cmtt/m/n/12 contributed statistics for the model. Per LP statistics are of
ten aggregated in the
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2270--2274
\OT1/cmtt/m/n/12 memory space of the model, and then the model computes some ov
erall statistics for
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2277--2283
\OT1/cmtt/m/n/12 The purpose of this function is to configure each LP according
 to its corresponding
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2277--2283
\OT1/cmtt/m/n/12 XML description. ROSS.Net identifies unknown XML elements and 
matches them with the
 []


Overfull \hbox (74.56029pt too wide) in paragraph at lines 2277--2283
\OT1/cmtt/m/n/12 individual models during the setup phase of the simulation (af
ter the LP has been initialized,
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2277--2283
\OT1/cmtt/m/n/12 of course). Modelers are free to construct any schema desired,
 and the LPs will be
 []

[43]
Overfull \hbox (18.98526pt too wide) in paragraph at lines 2286--2295
\OT1/cmtt/m/n/12 ROSS.Net contains the main function, and so these two function
s are used to give each
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2286--2295
\OT1/cmtt/m/n/12 layer model the opportunity to perform some processing before 
and after the execution
 []


Overfull \hbox (49.86028pt too wide) in paragraph at lines 2286--2295
\OT1/cmtt/m/n/12 of the simulation. In particular, the model main functions are
 called after ROSS internal
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 2286--2295
\OT1/cmtt/m/n/12 data structures have been configured, but before the LP initia
lization and XML handling
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2286--2295
\OT1/cmtt/m/n/12 phases. The purpose is to give the model a chance to initializ
e global memory prior
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2286--2295
\OT1/cmtt/m/n/12 to these operations for use by the LPs. The model finalization
 functions is provided
 []


Overfull \hbox (43.68527pt too wide) in paragraph at lines 2286--2295
\OT1/cmtt/m/n/12 to give each model the opportunity to report any final results
, and is called immediately
 []


Overfull \hbox (5.73506pt too wide) in paragraph at lines 2301--2310
[]\OT1/cmtt/m/n/12 The build system for ROSS.Net was originally chosen because 
of a lack of support
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 2301--2310
\OT1/cmtt/m/n/12 for shared libraries on some supercomputing systems (e.g., Cra
y XT4) and because static
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 2301--2310
\OT1/cmtt/m/n/12 libraries with unused code can impact the performance of an ap
plication. The autoconf
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2301--2310
\OT1/cmtt/m/n/12 and libtool build tools provide a great deal of facilities tha
t allow for the dynamic
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2301--2310
\OT1/cmtt/m/n/12 incorporation of models at compile time into the creation of a
 minimal executable.
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 2301--2310
\OT1/cmtt/m/n/12 Unfortunately, the high learning curve associated with these t
ools means that the build
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 2301--2310
\OT1/cmtt/m/n/12 system for ROSS.Net is not yet complete. In particular, models
 must still be manually
 []


Overfull \hbox (67.48509pt too wide) in paragraph at lines 2311--2314
[]\OT1/cmtt/m/n/12 The autoconf tool allows for configurable options to be spec
ified during the configuration
 []


Overfull \hbox (36.61008pt too wide) in paragraph at lines 2324--2326
[]\OT1/cmtt/m/n/12 In the following sections we will outline these steps in det
ail for a new model named
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2329--2333
\OT1/cmtt/m/n/12 The source code for all models is contained in the modules sub
directory. Within this
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2329--2333
\OT1/cmtt/m/n/12 directory are a series of subdirectories indicating a notional
 layering of protocol
 []

[44]
Overfull \hbox (18.08507pt too wide) in paragraph at lines 2358--2361
[]\OT1/cmtt/m/n/12 ROSS.Net does not use in any way the directory structure to 
determine the layering
 []


Overfull \hbox (5.73506pt too wide) in paragraph at lines 2362--2365
[]\OT1/cmtt/m/n/12 The final step is to create the file Makefile.am in your sub
directory indicating
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 2362--2365
\OT1/cmtt/m/n/12 your model source and header files, and to edit the Makefile.a
m in the directory above
 []

[45]
Overfull \hbox (12.81026pt too wide) in paragraph at lines 2391--2394
\OT1/cmtt/m/n/12 The first step in adding a new model to the current build syst
em is to edit the file
 []


Overfull \hbox (18.08507pt too wide) in paragraph at lines 2402--2403
[]\OT1/cmtt/m/n/12 And at the bottom of the file, the location of the model mus
t be specified so that
 []


Overfull \hbox (48.96008pt too wide) in paragraph at lines 2417--2422
[]\OT1/cmtt/m/n/12 Then simply run the bootstrap script to regenerate the confi
gure program. When running
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2417--2422
\OT1/cmtt/m/n/12 configure, the command line option --with-mymodel. While all o
f the source code will
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2425--2427
\OT1/cmtt/m/n/12 The ROSS.Net source code must be manually updated to include t
he hooks for each model
 []


Overfull \hbox (16.35606pt too wide) in paragraph at lines 2435--2441
[]\OT1/cmtt/m/n/12 Editing the file rn[]config.h, the header files for the new 
model must be included.
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2435--2441
\OT1/cmtt/m/n/12 In order to encapsulate and segregate the new model from the R
OSS.Net source code,
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2435--2441
\OT1/cmtt/m/n/12 the recommendation is to create a single header file for the n
ew model that includes
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 2435--2441
\OT1/cmtt/m/n/12 all other header files for the model. Then as new header files
 are added to the model,
 []

[46]
Overfull \hbox (5.73506pt too wide) in paragraph at lines 2481--2484
[]\OT1/cmtt/m/n/12 Editing the file rn.c involves informing the ROSS.Net source
 code what the names
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2481--2484
\OT1/cmtt/m/n/12 of the function hooks are, and incrementing a single variable 
in ROSS. The object in
 []

[47]
Overfull \hbox (11.91006pt too wide) in paragraph at lines 2548--2553
[]\OT1/cmtt/m/n/12 Your model will likely contain at least one memory buffer ty
pe, if not more. The
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 2548--2553
\OT1/cmtt/m/n/12 TCP model defines one data structure for all event types, usin
g one memory buffer queue.
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2548--2553
\OT1/cmtt/m/n/12 However, the OSPF model defines multiple event types that vary
 greatly in size, and
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2548--2553
\OT1/cmtt/m/n/12 so allocates five memory queues, one for each event type, to e
nsure that the memory
 []


Overfull \hbox (5.73506pt too wide) in paragraph at lines 2556--2558
[]\OT1/cmtt/m/n/12 At this point, assuming the source code files exist and has 
been configured, the
 []

[48]
Overfull \hbox (49.86028pt too wide) in paragraph at lines 2562--2577
\OT1/cmtt/m/n/12 The ROSS.Net paradigm was designed to match closely with the m
odeling environment provided
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 2562--2577
\OT1/cmtt/m/n/12 by the ROSS simulator. Models built in ROSS and ROSS.Net follo
w the LP paradigm, where
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2562--2577
\OT1/cmtt/m/n/12 LPs model processes, and events are passed between LPs model a
ctions occurring in the
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2562--2577
\OT1/cmtt/m/n/12 system. A simple example is a queuing system, where LPs model 
service queues, and
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2562--2577
\OT1/cmtt/m/n/12 events passing between queues convey information for processin
g at the queue. The
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2562--2577
\OT1/cmtt/m/n/12 IP layer in ROSS.Net implements a simple queuing model for lin
ks between nodes, and
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2562--2577
\OT1/cmtt/m/n/12 IP packets are sent between IP LPs. When an IP packet arrives 
at an IP LP, that LP
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2562--2577
\OT1/cmtt/m/n/12 then determines which link to use to forward the packet, and f
orwards the packet to
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2562--2577
\OT1/cmtt/m/n/12 the LP at the other end of the link. The timestamp of the forw
arded packet is chosen
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 2562--2577
\OT1/cmtt/m/n/12 based on the link bandwidth and delay, and the current load on
 the link. Queuing occurs
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2562--2577
\OT1/cmtt/m/n/12 when link bandwidth is consumed. Then the forwarded packet occ
urs at a time equal
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2562--2577
\OT1/cmtt/m/n/12 to the amount of time for the packet to traverse the link, plu
s the time of the last
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2562--2577
\OT1/cmtt/m/n/12 sent packet. The time of the last sent packet on the link is t
hen updated for the
 []


Overfull \hbox (11.91006pt too wide) in paragraph at lines 2578--2582
[]\OT1/cmtt/m/n/12 To build a model in ROSS.Net, the functions from Section 2.6
[] must be defined. In
 []


Overfull \hbox (68.38528pt too wide) in paragraph at lines 2578--2582
\OT1/cmtt/m/n/12 this section we will illustrate the process of developing a mo
del in ROSS.Net by illustrating
 []


Overfull \hbox (36.61008pt too wide) in paragraph at lines 2592--2599
[]\OT1/cmtt/m/n/12 The TCP source code defines these hooks in tcp-model.c. Duri
ng the call to the model
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2592--2599
\OT1/cmtt/m/n/12 main function we are in the initialization phase of the simula
tion, and ROSS.Net has
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2592--2599
\OT1/cmtt/m/n/12 processed the XML definitions, generated global data structure
s for the topology and
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2592--2599
\OT1/cmtt/m/n/12 initialized the ROSS data structures. However, the initializat
ion of LPs has yet to
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 2592--2599
\OT1/cmtt/m/n/12 take place. This is the point at which models have an opportun
ity to read configuration
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2592--2599
\OT1/cmtt/m/n/12 files, create global variables, add command line options, and 
initialize ROSS memory
 []

[49]
Overfull \hbox (59.58109pt too wide) in paragraph at lines 2654--2660
[]\OT1/cmtt/m/n/12 The first thing we see if the definition of the TCP model co
mmand line options, tcp[]opts.
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2654--2660
\OT1/cmtt/m/n/12 ROSS provides a simple mechanism for models to add their own c
ommand line arguments,
 []


Overfull \hbox (43.68527pt too wide) in paragraph at lines 2654--2660
\OT1/cmtt/m/n/12 and ROSS will process these arguments properly, setting the va
riable to the user supplied
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2654--2660
\OT1/cmtt/m/n/12 value, or keeping the default value if no user value defined, 
and printing the values
 []

[50]
Overfull \hbox (26.97707pt too wide) in paragraph at lines 2661--2665
[]\OT1/cmtt/m/n/12 In tcp[]md[]init the model performs the initialization of gl
obal variables, and passes
 []


Overfull \hbox (27.87726pt too wide) in paragraph at lines 2661--2665
\OT1/cmtt/m/n/12 the command line arguments for the model to ROSS via tw[]opt[]
add(..). Most importantly,
 []


Overfull \hbox (2.27705pt too wide) in paragraph at lines 2666--2670
[]\OT1/cmtt/m/n/12 During the call to the model finalization function, tcp[]md[
]final, the simulation
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2666--2670
\OT1/cmtt/m/n/12 has completed, and the LP finalization function has been calle
d for all LPs. This
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2666--2670
\OT1/cmtt/m/n/12 function gives the model a final opportunity to output results
 and statistics, and
 []


Overfull \hbox (16.35606pt too wide) in paragraph at lines 2671--2674
[]\OT1/cmtt/m/n/12 ROSS provides a helper function, tw[]ismaster(), that return
s true for a single CPU
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2671--2674
\OT1/cmtt/m/n/12 in the processor configuration. This function can be used for 
the gather phase of
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2677--2682
\OT1/cmtt/m/n/12 The TCP model defines the four primary LP function hooks in tc
p.c, and the per LP XML
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2677--2682
\OT1/cmtt/m/n/12 handler function in tcp-xml.c. The four primary hooks are the 
heart of the model,
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 2677--2682
\OT1/cmtt/m/n/12 and define the process that will occur at each stage of the LP
: init, event processing,
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 2685--2687
\OT1/cmtt/m/n/12 The data types for the TCP model are defined in the file tcp-t
ypes.h. The two primary
 []


Overfull \hbox (5.73506pt too wide) in paragraph at lines 2715--2717
[]\OT1/cmtt/m/n/12 The model defines the LP state variables required for proces
sing events, and the
 []

[51]
Overfull \hbox (31.33527pt too wide) in paragraph at lines 2720--2723
\OT1/cmtt/m/n/12 The first per LP function called is the LP XML handler. This a
llows each LP to receive
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2720--2723
\OT1/cmtt/m/n/12 its configuration from the XML definitions prior to their init
ialization functions
 []


Overfull \hbox (48.96008pt too wide) in paragraph at lines 2735--2738
[]\OT1/cmtt/m/n/12 Then the model defines an XML handler that ROSS.Net will cal
l during the initialization
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2735--2738
\OT1/cmtt/m/n/12 phase. ROSS.Net provides pointers to the state of the LP, the 
XML node pointer, and
 []


Overfull \hbox (48.96008pt too wide) in paragraph at lines 2761--2762
[]\OT1/cmtt/m/n/12 The behavior of the model is to use the XML element to defin
e each LPs state variables,
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2765--2766
\OT1/cmtt/m/n/12 The second function call is the LP initialization function. Th
is function defines
 []

[52]
Overfull \hbox (55.13509pt too wide) in paragraph at lines 2789--2795
[]\OT1/cmtt/m/n/12 The LP state variables are allocated and initialized and per
 LP data structures created.
 []


Overfull \hbox (60.48128pt too wide) in paragraph at lines 2789--2795
\OT1/cmtt/m/n/12 The function rn[]getmachine(..) is called to retrieve the id o
f the destination LP connected
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2789--2795
\OT1/cmtt/m/n/12 to this LP. Rather than relying on some application model to p
ass events down into
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2789--2795
\OT1/cmtt/m/n/12 the TCP layer, this TCP model is designed to start a file tran
sfer immediately upon
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2798--2801
\OT1/cmtt/m/n/12 The TCP LP event handler function defines the computation that
 occurs when events are
 []

[53]
Overfull \hbox (18.08507pt too wide) in paragraph at lines 2835--2839
[]\OT1/cmtt/m/n/12 The ROSS.Net event handler function prototype provides point
ers to our current LPs
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2835--2839
\OT1/cmtt/m/n/12 state, the current events bitfield (for reverse computation), 
the current event, and
 []


Overfull \hbox (62.21028pt too wide) in paragraph at lines 2835--2839
\OT1/cmtt/m/n/12 our own LP object. The objects are used in subsequent calls to
 ROSS and ROSS.Net functions. 
 []


Overfull \hbox (55.13509pt too wide) in paragraph at lines 2840--2844
[]\OT1/cmtt/m/n/12 The first step in the model is to retrieve our TCP event dat
a from the memory subsystem,
 []


Overfull \hbox (41.21526pt too wide) in paragraph at lines 2840--2844
\OT1/cmtt/m/n/12 via the calls to tw[]event[]memory[]get(..) and tw[]memory[]da
ta(..). This function retrieves
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 2840--2844
\OT1/cmtt/m/n/12 a memory buffer previously allocated and attached to the curre
nt event by the TCP model. 
 []


Overfull \hbox (55.13509pt too wide) in paragraph at lines 2845--2855
[]\OT1/cmtt/m/n/12 Inspecting the type ROSS.Net event received reveals the proc
essing required. Primarily,
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2845--2855
\OT1/cmtt/m/n/12 the ROSS.Net event type is one of TIMER, UPSTREAM or DOWNSTREA
M. If the event is of
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2845--2855
\OT1/cmtt/m/n/12 type DOWNSTREAM, then we can assume there is a model layer abo
ve ours, and the TCP
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2845--2855
\OT1/cmtt/m/n/12 model starts a new file transfer based on the size of the even
t passed in. Events
 []


Overfull \hbox (43.68527pt too wide) in paragraph at lines 2845--2855
\OT1/cmtt/m/n/12 of type TIMER can be constructed by protocol models to impleme
nt operating system alarms.
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2845--2855
\OT1/cmtt/m/n/12 Actual TCP implementations set an alarm called Receiver Timed 
Out (RTO). The idea is
 []


Overfull \hbox (74.56029pt too wide) in paragraph at lines 2845--2855
\OT1/cmtt/m/n/12 that when TCP sends data to a client, and that client fails to
 respond with an acknowledgement
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2845--2855
\OT1/cmtt/m/n/12 (ACK) within a set amount of time, then the TCP server should 
attempt to resend the
 []


Overfull \hbox (48.96008pt too wide) in paragraph at lines 2856--2861
[]\OT1/cmtt/m/n/12 Finally, if none of the above cases are true, then we are ei
ther a TCP client receiving
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2856--2861
\OT1/cmtt/m/n/12 data, or a TCP server receiving an ACK. This can be determined
 based on the value of
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2856--2861
\OT1/cmtt/m/n/12 the LP state variable connection, configured in the TCP LP ini
t function. The TCP
 []


Overfull \hbox (18.08507pt too wide) in paragraph at lines 2862--2867
[]\OT1/cmtt/m/n/12 At the completion of event processing, the final step is to 
free the memory buffer
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2862--2867
\OT1/cmtt/m/n/12 associated with the event. This is an important step, because 
it allows the memory
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2862--2867
\OT1/cmtt/m/n/12 buffer to be accounted for by the simulation system. It will b
ecome available only
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2862--2867
\OT1/cmtt/m/n/12 once ROSS determines that the current event and memory buffers
 are safe to reclaim. 
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2870--2875
\OT1/cmtt/m/n/12 The TCP LP reverse computation event handler function defines 
the reverse computation
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2870--2875
\OT1/cmtt/m/n/12 that occurs when events are being rolled back by the simulator
. The primary purpose
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2870--2875
\OT1/cmtt/m/n/12 of this function is to give the model a chance to restore the 
state of the LP prior
 []

[54]
Overfull \hbox (5.73506pt too wide) in paragraph at lines 2901--2907
[]\OT1/cmtt/m/n/12 As with the event handler, we must first determine the type 
of the current event
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2901--2907
\OT1/cmtt/m/n/12 so that we can compute the reverse code an restore the LP stat
e. Following the same
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2901--2907
\OT1/cmtt/m/n/12 logic, the event must be either the RTO timer, data from a TCP
 server, or an ACK from
 []


Overfull \hbox (37.51027pt too wide) in paragraph at lines 2901--2907
\OT1/cmtt/m/n/12 a TCP client. If the event being rolled back is from the layer
 above us, then no action
 []


Overfull \hbox (24.26007pt too wide) in paragraph at lines 2908--2913
[]\OT1/cmtt/m/n/12 Memory buffers must be reverse computed as well, and the ROS
S memory buffer library
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2908--2913
\OT1/cmtt/m/n/12 provides API calls to simplify this process. First, we must un
-free the event. At
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2908--2913
\OT1/cmtt/m/n/12 the conclusion of the reverse event handler, we must re-attach
 the memory buffer to
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2908--2913
\OT1/cmtt/m/n/12 the event so that when forward processing resumes, the memory 
buffer is available. 
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2916--2917
\OT1/cmtt/m/n/12 The TCP LP finalization functions gathers per LP statistics in
to a global variable
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 2937--2941
\OT1/cmtt/m/n/12 Sending events in ROSS.Net is slightly different than in ROSS 
because ROSS.Net provides
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2937--2941
\OT1/cmtt/m/n/12 functionality required by most if not all network protocol mod
els. For purposes of
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2937--2941
\OT1/cmtt/m/n/12 demonstration, the TCP model defines a helper function for sen
ding events in the TCP
 []


Overfull \hbox (160.95778pt too wide) in paragraph at lines 2964--2964
[]\OT1/cmtt/m/n/10.95 tcp_event_send(tcp_state * state, tw_lpid src, tw_stime t
s, tw_lpid dst, int size, int seq_num, int ack, tw_lp * lp)[] 
 []

[55]
Overfull \hbox (39.32707pt too wide) in paragraph at lines 2967--2970
[]\OT1/cmtt/m/n/12 First, the TCP model calls rn[]event[]new, supplying the des
tination LP's id, the offset
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2967--2970
\OT1/cmtt/m/n/12 timestamp, a pointer to the current LP, the direction of the e
vent in the protocol
 []


Overfull \hbox (11.91006pt too wide) in paragraph at lines 2971--2978
[]\OT1/cmtt/m/n/12 The destination LP is determined by the LPs connection from 
the Traffic topology.
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 2971--2978
\OT1/cmtt/m/n/12 If there are no layers defined in the XML description beneath 
TCP LPs, then the event
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 2971--2978
\OT1/cmtt/m/n/12 will be sent directly to the destination LP. If models such as
 the IP model are defined
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 2971--2978
\OT1/cmtt/m/n/12 below TCP, the TCP packets will be routed through the IP route
r network. The TCP model
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2971--2978
\OT1/cmtt/m/n/12 need not be aware of model layers below TCP, ROSS.Net will ens
ure proper delivery of
 []


Overfull \hbox (61.31009pt too wide) in paragraph at lines 2979--2983
[]\OT1/cmtt/m/n/12 Whether the TCP model is sending an acknowledgement, or data
 packet, the offset timestamp
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2979--2983
\OT1/cmtt/m/n/12 is always 0.0. This TCP implementation does not account for qu
euing delays on the
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 2979--2983
\OT1/cmtt/m/n/12 packet, instead relying on the layering of protocol models to 
provide queuing semantics
 []


Overfull \hbox (24.26007pt too wide) in paragraph at lines 2984--2989
[]\OT1/cmtt/m/n/12 Whether an acknowledgment or data, every TCP packet flows do
wn through the protocol
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2984--2989
\OT1/cmtt/m/n/12 stack, or DOWNSTREAM. When a TCP client receives a complete ev
ent, this is the only
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2984--2989
\OT1/cmtt/m/n/12 time the TCP model does not use this function. Instead, the TC
P model defines code
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2984--2989
\OT1/cmtt/m/n/12 specific to that purpose elsewhere in the code. When sending a
n UPSTREAM event, the
 []


Overfull \hbox (55.13509pt too wide) in paragraph at lines 2994--3005
[]\OT1/cmtt/m/n/12 Here the source and destination are the same, the timestamp 
offset is 0.0, the direction
 []


Overfull \hbox (25.16026pt too wide) in paragraph at lines 2994--3005
\OT1/cmtt/m/n/12 is UPSTREAM, and the size of the data being sent is the full s
ize of the file received
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2994--3005
\OT1/cmtt/m/n/12 over the course of the transmission. No memory buffer is attac
hed to the event, as
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2994--3005
\OT1/cmtt/m/n/12 any layers above the TCP layer have no knowledge of the TCP me
mory buffer structure.
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2994--3005
\OT1/cmtt/m/n/12 If the application on the sending side provided am application
 memory buffer, then
 []


Overfull \hbox (6.63525pt too wide) in paragraph at lines 2994--3005
\OT1/cmtt/m/n/12 the TCP model should provide that memory buffer on the receive
rs side when the send
 []


Overfull \hbox (12.81026pt too wide) in paragraph at lines 2994--3005
\OT1/cmtt/m/n/12 completes. This is not currently implemented in this TCP model
. This functionality
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 2994--3005
\OT1/cmtt/m/n/12 could be implemented by simply having the TCP server attach th
e application memory
 []


Overfull \hbox (31.33527pt too wide) in paragraph at lines 2994--3005
\OT1/cmtt/m/n/12 buffer on an event and sending it to the TCP client. The TCP c
lient would then forward
 []

[56]
Overfull \hbox (48.96008pt too wide) in paragraph at lines 3006--3011
[]\OT1/cmtt/m/n/12 The TCP model allocates a memory buffer from the ROSS system
, fills in the data portion
 []


Overfull \hbox (69.37328pt too wide) in paragraph at lines 3006--3011
\OT1/cmtt/m/n/12 of the packet, and attaches the memory buffer to the event by 
calling tw[]event[]memory[]set(..).
 []


Overfull \hbox (18.98526pt too wide) in paragraph at lines 3006--3011
\OT1/cmtt/m/n/12 Each protocol model defines and uses its own memory buffers fo
r application data, and
 []


Overfull \hbox (43.68527pt too wide) in paragraph at lines 3006--3011
\OT1/cmtt/m/n/12 attaches them to newly created events, and pulls them off even
ts during event processing. 
 []


Overfull \hbox (55.13509pt too wide) in paragraph at lines 3012--3015
[]\OT1/cmtt/m/n/12 Finally, the TCP model sends the event. The event will be pa
ssed down to lower protocol
 []


Overfull \hbox (0.46025pt too wide) in paragraph at lines 3012--3015
\OT1/cmtt/m/n/12 models, if any are defined on this node, and upon reaching the
 bottom of the stack
 []


Underfull \hbox (badness 10000) in paragraph at lines 3019--3023
[]\OT1/cmtt/m/n/12 D. W. Bauer, G. Yaun, C. D. Carothers, M. Yuksel, and S. Kal
yanaraman,
 []


Underfull \hbox (badness 10000) in paragraph at lines 3019--3023
\OT1/cmtt/m/n/12 ``A case study in meta-simulation design and performance analy
sis for
 []


Underfull \hbox (badness 10000) in paragraph at lines 3019--3023
\OT1/cmtt/m/n/12 large-scale networks,'' in \OT1/cmtt/m/it/12 Proceedings of th
e 2003 Winter Simulation
 []


Underfull \hbox (badness 10000) in paragraph at lines 3025--3030
[]\OT1/cmtt/m/n/12 D. Bauer, G. Yaun, C. Carothers, M. Yuksel, and S. Kalyanara
man, ``A case
 []


Underfull \hbox (badness 10000) in paragraph at lines 3025--3030
\OT1/cmtt/m/n/12 study in meta-simulation design and performance analysis for l
arge-scale
 []


Underfull \hbox (badness 10000) in paragraph at lines 3025--3030
\OT1/cmtt/m/n/12 networks,'' in \OT1/cmtt/m/it/12 Proceedings of the 36th confe
rence on Winter simulation\OT1/cmtt/m/n/12 .
 []


Underfull \hbox (badness 10000) in paragraph at lines 3032--3036
\OT1/cmtt/m/n/12 networks using time warp.  In \OT1/cmtt/m/it/12 Proceedings of
 the 9th Workshop on Parallel
 []


Underfull \hbox (badness 10000) in paragraph at lines 3038--3042
[]\OT1/cmtt/m/n/12 C. D. Carothers, K. Perumalla and R. M. Fujimoto.  Efficient
 Parallel
 []


Underfull \hbox (badness 10000) in paragraph at lines 3038--3042
\OT1/cmtt/m/n/12 Simulation Using Reverse Computation  \OT1/cmtt/m/it/12 ACM Tr
ansactions on Modeling and
 []


Underfull \hbox (badness 10000) in paragraph at lines 3044--3048
[]\OT1/cmtt/m/n/12 C. D. Carothers, D. Bauer and S. Pearce.  High-Performance, 
Low Memory,
 []


Underfull \hbox (badness 8151) in paragraph at lines 3044--3048
\OT1/cmtt/m/n/12 Modular Time Warp System,  In \OT1/cmtt/m/it/12 Proceedings of
 the 14th Workshop of Parallel
 []


Underfull \hbox (badness 10000) in paragraph at lines 3050--3053
[]\OT1/cmtt/m/n/12 C. D. Carothers, D. W. Bauer, and S. O. Pearce, ``Ross: A hi
gh-performance,
 []


Underfull \hbox (badness 10000) in paragraph at lines 3050--3053
\OT1/cmtt/m/n/12 low memory, modular time warp system,'' \OT1/cmtt/m/it/12 Jour
nal of Parallel and Distributed
 []


Underfull \hbox (badness 7256) in paragraph at lines 3055--3059
[]\OT1/cmtt/m/n/12 S. Das, R. Fujimoto, K. Panesar, D. Allison, and M. Hybinett
e.  GTW: A Time
 []


Underfull \hbox (badness 10000) in paragraph at lines 3055--3059
\OT1/cmtt/m/n/12 Warp system for shared memory multiprocessors.  In \OT1/cmtt/m
/it/12 1994 Winter Simulation
 []


Underfull \hbox (badness 1303) in paragraph at lines 3061--3064
[]\OT1/cmtt/m/n/12 R. M. Fujimoto.  Parallel discrete-event simulation.  \OT1/c
mtt/m/it/12 Communications of the
 []

[57]
Underfull \hbox (badness 7256) in paragraph at lines 3071--3075
[]\OT1/cmtt/m/n/12 D. R. Jefferson and H. Sowizral.  Fast concurrent simulation
 using the Time
 []


Underfull \hbox (badness 10000) in paragraph at lines 3071--3075
\OT1/cmtt/m/n/12 Warp mechanism, part I: Local control.  Technical Report N-190
6-AF, RAND
 []


Underfull \hbox (badness 2205) in paragraph at lines 3077--3081
[]\OT1/cmtt/m/n/12 D. R. Jefferson.  Virtual time.  \OT1/cmtt/m/it/12 ACM Trans
actions on Programming Languages
 []


Underfull \hbox (badness 10000) in paragraph at lines 3083--3087
[]\OT1/cmtt/m/n/12 P. L'Ecuyer and T. H. Andres.  ``A Random Number Generator B
ased on the
 []


Underfull \hbox (badness 10000) in paragraph at lines 3089--3094
[]\OT1/cmtt/m/n/12 R. Ronngren and Rassul Ayani.  ``A Comparative Study of Para
llel and
 []


Underfull \hbox (badness 10000) in paragraph at lines 3089--3094
\OT1/cmtt/m/n/12 Sequential Priority Queue Algorithms'',  \OT1/cmtt/m/it/12 ACM
 Transactions on Modeling and
 []


Underfull \hbox (badness 10000) in paragraph at lines 3096--3100
[]\OT1/cmtt/m/n/12 G. R. Yaun, D. W. Bauer, H. L. Bhutada, C. D. Carothers, M. 
Yuksel, and
 []


Underfull \hbox (badness 10000) in paragraph at lines 3096--3100
\OT1/cmtt/m/n/12 S. Kalyanaraman, ``Large-scale network simulation techniques: 
examples of
 []


Underfull \hbox (badness 10000) in paragraph at lines 3096--3100
\OT1/cmtt/m/n/12 tcp and ospf models,'' \OT1/cmtt/m/it/12 SIGCOMM Comput. Commu
n. Rev.\OT1/cmtt/m/n/12 , vol. 33, no. 3, pp.
 []


Underfull \hbox (badness 10000) in paragraph at lines 3102--3105
[]\OT1/cmtt/m/n/12 T. Ye and S. Kalyanaraman, ``A unified search framework for 
large-scale
 []


Underfull \hbox (badness 10000) in paragraph at lines 3102--3105
\OT1/cmtt/m/n/12 black-box optimization,'' Rensselaer Polytechnic Institute, EC
SE Department,
 []


Underfull \hbox (badness 10000) in paragraph at lines 3107--3112
[]\OT1/cmtt/m/n/12 G. Yaun, C. D. Carothers, and S. Kalyanaraman, ``Large-scale
 tcp models
 []


Underfull \hbox (badness 10000) in paragraph at lines 3107--3112
\OT1/cmtt/m/n/12 using optimistic parallel simulation,'' in \OT1/cmtt/m/it/12 P
ADS '03: Proceedings of the
 []


Underfull \hbox (badness 2142) in paragraph at lines 3107--3112
\OT1/cmtt/m/it/12 seventeenth workshop on Parallel and distributed simulation\O
T1/cmtt/m/n/12 . Washington,
 []

[58] (./ross-rossnet-ug.aux)

LaTeX Font Warning: Some font shapes were not available, defaults substituted.

 ) 
Here is how much of TeX's memory you used:
 697 strings out of 94087
 8299 string characters out of 1167722
 59847 words of memory out of 3500000
 4016 multiletter control sequences out of 10000+50000
 10643 words of font info for 39 fonts, out of 1200000 for 2000
 645 hyphenation exceptions out of 8191
 32i,6n,21p,443b,289s stack positions out of 5000i,500n,6000p,200000b,5000s

Output written on ross-rossnet-ug.dvi (58 pages, 152352 bytes).
